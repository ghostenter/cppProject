<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Crypto++: validat3.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>validat3.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// validat3.cpp - written and placed in the public domain by Wei Dai</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include "pch.h"</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include "validate.h"</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="preprocessor">#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1</span>
<a name="l00007"></a>00007 <span class="preprocessor"></span><span class="preprocessor">#include "smartptr.h"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "crc.h"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "adler32.h"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "md2.h"</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "md4.h"</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include "md5.h"</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include "sha.h"</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include "tiger.h"</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include "ripemd.h"</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#include "hmac.h"</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include "ttmac.h"</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include "<a class="code" href="integer_8h.html">integer.h</a>"</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include "pwdbased.h"</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include "filters.h"</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include "hex.h"</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include "files.h"</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 USING_NAMESPACE(CryptoPP)
<a name="l00030"></a>00030 USING_NAMESPACE(std)
<a name="l00031"></a>00031 
<a name="l00032"></a><a class="code" href="struct_hash_test_tuple.html">00032</a> struct <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>
<a name="l00033"></a>00033 {
<a name="l00034"></a><a class="code" href="struct_hash_test_tuple.html#7d6758dc69a19fd83ba1226d50b830d0">00034</a>         HashTestTuple(<span class="keyword">const</span> <span class="keywordtype">char</span> *input, <span class="keyword">const</span> <span class="keywordtype">char</span> *output, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> repeatTimes=1)
<a name="l00035"></a>00035                 : input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}
<a name="l00036"></a>00036         
<a name="l00037"></a><a class="code" href="struct_hash_test_tuple.html#fa515f851fca4eda7e680a978af2e562">00037</a>         HashTestTuple(<span class="keyword">const</span> <span class="keywordtype">char</span> *input, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inputLen, <span class="keyword">const</span> <span class="keywordtype">char</span> *output, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> repeatTimes)
<a name="l00038"></a>00038                 : input((byte *)input), output((byte *)output), inputLen(inputLen), repeatTimes(repeatTimes) {}
<a name="l00039"></a>00039 
<a name="l00040"></a><a class="code" href="struct_hash_test_tuple.html#123c8dac86390344a56fb2a7ad8a4e06">00040</a>         <span class="keyword">const</span> byte *input, *output;
<a name="l00041"></a><a class="code" href="struct_hash_test_tuple.html#8be9305641d4be19bec31c8c3e33065d">00041</a>         <span class="keywordtype">size_t</span> inputLen;
<a name="l00042"></a><a class="code" href="struct_hash_test_tuple.html#8cbb11493f22b3d626945f587b0a649a">00042</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> repeatTimes;
<a name="l00043"></a>00043 };
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="keywordtype">bool</span> HashModuleTest(<a class="code" href="class_hash_transformation.html" title="interface for hash functions and data processing part of MACs">HashTransformation</a> &amp;md, <span class="keyword">const</span> <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> *testSet, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> testSetSize)
<a name="l00046"></a>00046 {
<a name="l00047"></a>00047         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>, fail;
<a name="l00048"></a>00048         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> digest(md.<a class="code" href="class_hash_transformation.html#41faf8b1293a6c72390cb0c8bd668097" title="size of the hash returned by Final()">DigestSize</a>());
<a name="l00049"></a>00049 
<a name="l00050"></a>00050         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;testSetSize; i++)
<a name="l00051"></a>00051         {
<a name="l00052"></a>00052                 <span class="keywordtype">unsigned</span> j;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054                 <span class="keywordflow">for</span> (j=0; j&lt;testSet[i].<a class="code" href="struct_hash_test_tuple.html#8cbb11493f22b3d626945f587b0a649a">repeatTimes</a>; j++)
<a name="l00055"></a>00055                         md.<a class="code" href="class_hash_transformation.html#afabefaf445b65d3ba0d8e1c0294afe5" title="process more input">Update</a>(testSet[i].<a class="code" href="struct_hash_test_tuple.html#5a32fe3ce744ed09b7dd9db3dd374754">input</a>, testSet[i].<a class="code" href="struct_hash_test_tuple.html#8be9305641d4be19bec31c8c3e33065d">inputLen</a>);
<a name="l00056"></a>00056                 md.<a class="code" href="class_hash_transformation.html#a0b8c7a110d8968268fd02ec32b9a8e8" title="compute hash for current message, then restart for a new message">Final</a>(digest);
<a name="l00057"></a>00057                 fail = memcmp(digest, testSet[i].output, md.<a class="code" href="class_hash_transformation.html#41faf8b1293a6c72390cb0c8bd668097" title="size of the hash returned by Final()">DigestSize</a>()) != 0;
<a name="l00058"></a>00058                 pass = pass &amp;&amp; !fail;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060                 cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED   "</span> : <span class="stringliteral">"passed   "</span>);
<a name="l00061"></a>00061                 <span class="keywordflow">for</span> (j=0; j&lt;md.<a class="code" href="class_hash_transformation.html#41faf8b1293a6c72390cb0c8bd668097" title="size of the hash returned by Final()">DigestSize</a>(); j++)
<a name="l00062"></a>00062                         cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">'0'</span>) &lt;&lt; hex &lt;&lt; (int)digest[j];
<a name="l00063"></a>00063                 cout &lt;&lt; <span class="stringliteral">"   \""</span> &lt;&lt; (<span class="keywordtype">char</span> *)testSet[i].input &lt;&lt; <span class="charliteral">'\"'</span>;
<a name="l00064"></a>00064                 <span class="keywordflow">if</span> (testSet[i].repeatTimes != 1)
<a name="l00065"></a>00065                         cout &lt;&lt; <span class="stringliteral">" repeated "</span> &lt;&lt; dec &lt;&lt; testSet[i].<a class="code" href="struct_hash_test_tuple.html#8cbb11493f22b3d626945f587b0a649a">repeatTimes</a> &lt;&lt; <span class="stringliteral">" times"</span>;
<a name="l00066"></a>00066                 cout  &lt;&lt; endl;
<a name="l00067"></a>00067         }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069         <span class="keywordflow">return</span> pass;
<a name="l00070"></a>00070 }
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="keywordtype">bool</span> ValidateCRC32()
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00075"></a>00075         {
<a name="l00076"></a>00076                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">""</span>, <span class="stringliteral">"\x00\x00\x00\x00"</span>),
<a name="l00077"></a>00077                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"a"</span>, <span class="stringliteral">"\x43\xbe\xb7\xe8"</span>),
<a name="l00078"></a>00078                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\xc2\x41\x24\x35"</span>),
<a name="l00079"></a>00079                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"message digest"</span>, <span class="stringliteral">"\x7f\x9d\x15\x20"</span>),
<a name="l00080"></a>00080                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdefghijklmnopqrstuvwxyz"</span>, <span class="stringliteral">"\xbd\x50\x27\x4c"</span>),
<a name="l00081"></a>00081                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>, <span class="stringliteral">"\xd2\xe6\xc2\x1f"</span>),
<a name="l00082"></a>00082                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"12345678901234567890123456789012345678901234567890123456789012345678901234567890"</span>, <span class="stringliteral">"\x72\x4a\xa9\x7c"</span>),
<a name="l00083"></a>00083                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"123456789"</span>, <span class="stringliteral">"\x26\x39\xf4\xcb"</span>)
<a name="l00084"></a>00084         };
<a name="l00085"></a>00085 
<a name="l00086"></a>00086         <a class="code" href="class_c_r_c32.html" title="CRC Checksum Calculation.">CRC32</a> crc;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088         cout &lt;&lt; <span class="stringliteral">"\nCRC-32 validation suite running...\n\n"</span>;
<a name="l00089"></a>00089         <span class="keywordflow">return</span> HashModuleTest(crc, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0]));
<a name="l00090"></a>00090 }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="keywordtype">bool</span> ValidateAdler32()
<a name="l00093"></a>00093 {
<a name="l00094"></a>00094         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00095"></a>00095         {
<a name="l00096"></a>00096                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">""</span>, <span class="stringliteral">"\x00\x00\x00\x01"</span>),
<a name="l00097"></a>00097                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"a"</span>, <span class="stringliteral">"\x00\x62\x00\x62"</span>),
<a name="l00098"></a>00098                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\x02\x4d\x01\x27"</span>),
<a name="l00099"></a>00099                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"message digest"</span>, <span class="stringliteral">"\x29\x75\x05\x86"</span>),
<a name="l00100"></a>00100                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdefghijklmnopqrstuvwxyz"</span>, <span class="stringliteral">"\x90\x86\x0b\x20"</span>),
<a name="l00101"></a>00101                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>, <span class="stringliteral">"\x8a\xdb\x15\x0c"</span>),
<a name="l00102"></a>00102                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>, <span class="stringliteral">"\x15\xd8\x70\xf9"</span>, 15625)
<a name="l00103"></a>00103         };
<a name="l00104"></a>00104 
<a name="l00105"></a>00105         <a class="code" href="class_adler32.html" title="ADLER-32 checksum calculations.">Adler32</a> md;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         cout &lt;&lt; <span class="stringliteral">"\nAdler-32 validation suite running...\n\n"</span>;
<a name="l00108"></a>00108         <span class="keywordflow">return</span> HashModuleTest(md, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0]));
<a name="l00109"></a>00109 }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="keywordtype">bool</span> ValidateMD2()
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00114"></a>00114         {
<a name="l00115"></a>00115                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">""</span>, <span class="stringliteral">"\x83\x50\xe5\xa3\xe2\x4c\x15\x3d\xf2\x27\x5c\x9f\x80\x69\x27\x73"</span>),
<a name="l00116"></a>00116                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"a"</span>, <span class="stringliteral">"\x32\xec\x01\xec\x4a\x6d\xac\x72\xc0\xab\x96\xfb\x34\xc0\xb5\xd1"</span>),
<a name="l00117"></a>00117                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\xda\x85\x3b\x0d\x3f\x88\xd9\x9b\x30\x28\x3a\x69\xe6\xde\xd6\xbb"</span>),
<a name="l00118"></a>00118                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"message digest"</span>, <span class="stringliteral">"\xab\x4f\x49\x6b\xfb\x2a\x53\x0b\x21\x9f\xf3\x30\x31\xfe\x06\xb0"</span>),
<a name="l00119"></a>00119                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdefghijklmnopqrstuvwxyz"</span>, <span class="stringliteral">"\x4e\x8d\xdf\xf3\x65\x02\x92\xab\x5a\x41\x08\xc3\xaa\x47\x94\x0b"</span>),
<a name="l00120"></a>00120                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>, <span class="stringliteral">"\xda\x33\xde\xf2\xa4\x2d\xf1\x39\x75\x35\x28\x46\xc3\x03\x38\xcd"</span>),
<a name="l00121"></a>00121                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"12345678901234567890123456789012345678901234567890123456789012345678901234567890"</span>, <span class="stringliteral">"\xd5\x97\x6f\x79\xd8\x3d\x3a\x0d\xc9\x80\x6c\x3c\x66\xf3\xef\xd8"</span>)
<a name="l00122"></a>00122         };
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         Weak::MD2 md2;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126         cout &lt;&lt; <span class="stringliteral">"\nMD2 validation suite running...\n\n"</span>;
<a name="l00127"></a>00127         <span class="keywordflow">return</span> HashModuleTest(md2, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0]));
<a name="l00128"></a>00128 }
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="keywordtype">bool</span> ValidateMD4()
<a name="l00131"></a>00131 {
<a name="l00132"></a>00132         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00133"></a>00133         {
<a name="l00134"></a>00134                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">""</span>, <span class="stringliteral">"\x31\xd6\xcf\xe0\xd1\x6a\xe9\x31\xb7\x3c\x59\xd7\xe0\xc0\x89\xc0"</span>),
<a name="l00135"></a>00135                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"a"</span>, <span class="stringliteral">"\xbd\xe5\x2c\xb3\x1d\xe3\x3e\x46\x24\x5e\x05\xfb\xdb\xd6\xfb\x24"</span>),
<a name="l00136"></a>00136                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\xa4\x48\x01\x7a\xaf\x21\xd8\x52\x5f\xc1\x0a\xe8\x7a\xa6\x72\x9d"</span>),
<a name="l00137"></a>00137                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"message digest"</span>, <span class="stringliteral">"\xd9\x13\x0a\x81\x64\x54\x9f\xe8\x18\x87\x48\x06\xe1\xc7\x01\x4b"</span>),
<a name="l00138"></a>00138                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdefghijklmnopqrstuvwxyz"</span>, <span class="stringliteral">"\xd7\x9e\x1c\x30\x8a\xa5\xbb\xcd\xee\xa8\xed\x63\xdf\x41\x2d\xa9"</span>),
<a name="l00139"></a>00139                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>, <span class="stringliteral">"\x04\x3f\x85\x82\xf2\x41\xdb\x35\x1c\xe6\x27\xe1\x53\xe7\xf0\xe4"</span>),
<a name="l00140"></a>00140                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"12345678901234567890123456789012345678901234567890123456789012345678901234567890"</span>, <span class="stringliteral">"\xe3\x3b\x4d\xdc\x9c\x38\xf2\x19\x9c\x3e\x7b\x16\x4f\xcc\x05\x36"</span>)
<a name="l00141"></a>00141         };
<a name="l00142"></a>00142 
<a name="l00143"></a>00143         Weak::MD4 md4;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145         cout &lt;&lt; <span class="stringliteral">"\nMD4 validation suite running...\n\n"</span>;
<a name="l00146"></a>00146         <span class="keywordflow">return</span> HashModuleTest(md4, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0]));
<a name="l00147"></a>00147 }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="keywordtype">bool</span> ValidateMD5()
<a name="l00150"></a>00150 {
<a name="l00151"></a>00151         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00152"></a>00152         {
<a name="l00153"></a>00153                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">""</span>, <span class="stringliteral">"\xd4\x1d\x8c\xd9\x8f\x00\xb2\x04\xe9\x80\x09\x98\xec\xf8\x42\x7e"</span>),
<a name="l00154"></a>00154                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"a"</span>, <span class="stringliteral">"\x0c\xc1\x75\xb9\xc0\xf1\xb6\xa8\x31\xc3\x99\xe2\x69\x77\x26\x61"</span>),
<a name="l00155"></a>00155                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\x90\x01\x50\x98\x3c\xd2\x4f\xb0\xd6\x96\x3f\x7d\x28\xe1\x7f\x72"</span>),
<a name="l00156"></a>00156                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"message digest"</span>, <span class="stringliteral">"\xf9\x6b\x69\x7d\x7c\xb7\x93\x8d\x52\x5a\x2f\x31\xaa\xf1\x61\xd0"</span>),
<a name="l00157"></a>00157                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdefghijklmnopqrstuvwxyz"</span>, <span class="stringliteral">"\xc3\xfc\xd3\xd7\x61\x92\xe4\x00\x7d\xfb\x49\x6c\xca\x67\xe1\x3b"</span>),
<a name="l00158"></a>00158                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>, <span class="stringliteral">"\xd1\x74\xab\x98\xd2\x77\xd9\xf5\xa5\x61\x1c\x2c\x9f\x41\x9d\x9f"</span>),
<a name="l00159"></a>00159                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"12345678901234567890123456789012345678901234567890123456789012345678901234567890"</span>, <span class="stringliteral">"\x57\xed\xf4\xa2\x2b\xe3\xc9\x55\xac\x49\xda\x2e\x21\x07\xb6\x7a"</span>)
<a name="l00160"></a>00160         };
<a name="l00161"></a>00161 
<a name="l00162"></a>00162         Weak::MD5 md5;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164         cout &lt;&lt; <span class="stringliteral">"\nMD5 validation suite running...\n\n"</span>;
<a name="l00165"></a>00165         <span class="keywordflow">return</span> HashModuleTest(md5, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0]));
<a name="l00166"></a>00166 }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="keywordtype">bool</span> ValidateSHA()
<a name="l00169"></a>00169 {
<a name="l00170"></a>00170         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00171"></a>00171         {
<a name="l00172"></a>00172                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\xA9\x99\x3E\x36\x47\x06\x81\x6A\xBA\x3E\x25\x71\x78\x50\xC2\x6C\x9C\xD0\xD8\x9D"</span>),
<a name="l00173"></a>00173                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"</span>, <span class="stringliteral">"\x84\x98\x3E\x44\x1C\x3B\xD2\x6E\xBA\xAE\x4A\xA1\xF9\x51\x29\xE5\xE5\x46\x70\xF1"</span>),
<a name="l00174"></a>00174                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>, <span class="stringliteral">"\x34\xAA\x97\x3C\xD4\xC4\xDA\xA4\xF6\x1E\xEB\x2B\xDB\xAD\x27\x31\x65\x34\x01\x6F"</span>, 15625)
<a name="l00175"></a>00175         };
<a name="l00176"></a>00176 
<a name="l00177"></a>00177         <a class="code" href="class_s_h_a1.html" title="SHA-1">SHA</a> sha;
<a name="l00178"></a>00178 
<a name="l00179"></a>00179         cout &lt;&lt; <span class="stringliteral">"\nSHA validation suite running...\n\n"</span>;
<a name="l00180"></a>00180         <span class="keywordflow">return</span> HashModuleTest(sha, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0]));
<a name="l00181"></a>00181 }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="keywordtype">bool</span> ValidateSHA2()
<a name="l00184"></a>00184 {
<a name="l00185"></a>00185         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet256[] = 
<a name="l00186"></a>00186         {
<a name="l00187"></a>00187                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\xba\x78\x16\xbf\x8f\x01\xcf\xea\x41\x41\x40\xde\x5d\xae\x22\x23\xb0\x03\x61\xa3\x96\x17\x7a\x9c\xb4\x10\xff\x61\xf2\x00\x15\xad"</span>),
<a name="l00188"></a>00188                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"</span>, <span class="stringliteral">"\x24\x8d\x6a\x61\xd2\x06\x38\xb8\xe5\xc0\x26\x93\x0c\x3e\x60\x39\xa3\x3c\xe4\x59\x64\xff\x21\x67\xf6\xec\xed\xd4\x19\xdb\x06\xc1"</span>),
<a name="l00189"></a>00189         };
<a name="l00190"></a>00190 
<a name="l00191"></a>00191         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193         cout &lt;&lt; <span class="stringliteral">"\nSHA-256 validation suite running...\n\n"</span>;
<a name="l00194"></a>00194         <a class="code" href="class_s_h_a256.html" title="implements the SHA-256 standard">SHA256</a> sha256;
<a name="l00195"></a>00195         pass = HashModuleTest(sha256, testSet256, <span class="keyword">sizeof</span>(testSet256)/<span class="keyword">sizeof</span>(testSet256[0])) &amp;&amp; pass;
<a name="l00196"></a>00196 
<a name="l00197"></a>00197         cout &lt;&lt; <span class="stringliteral">"\nSHA-384 validation suite running...\n\n"</span>;
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="preprocessor">#ifdef WORD64_AVAILABLE</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span>        <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet384[] = 
<a name="l00201"></a>00201         {
<a name="l00202"></a>00202                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\xcb\x00\x75\x3f\x45\xa3\x5e\x8b\xb5\xa0\x3d\x69\x9a\xc6\x50\x07\x27\x2c\x32\xab\x0e\xde\xd1\x63\x1a\x8b\x60\x5a\x43\xff\x5b\xed\x80\x86\x07\x2b\xa1\xe7\xcc\x23\x58\xba\xec\xa1\x34\xc8\x25\xa7"</span>),
<a name="l00203"></a>00203                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"</span>, <span class="stringliteral">"\x09\x33\x0c\x33\xf7\x11\x47\xe8\x3d\x19\x2f\xc7\x82\xcd\x1b\x47\x53\x11\x1b\x17\x3b\x3b\x05\xd2\x2f\xa0\x80\x86\xe3\xb0\xf7\x12\xfc\xc7\xc7\x1a\x55\x7e\x2d\xb9\x66\xc3\xe9\xfa\x91\x74\x60\x39"</span>),
<a name="l00204"></a>00204         };
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         <a class="code" href="class_s_h_a384.html" title="implements the SHA-384 standard">SHA384</a> sha384;
<a name="l00207"></a>00207         pass = HashModuleTest(sha384, testSet384, <span class="keyword">sizeof</span>(testSet384)/<span class="keyword">sizeof</span>(testSet384[0])) &amp;&amp; pass;
<a name="l00208"></a>00208 <span class="preprocessor">#else</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span>        cout &lt;&lt; <span class="stringliteral">"word64 not available, skipping SHA-384 validation."</span> &lt;&lt; endl;
<a name="l00210"></a>00210 <span class="preprocessor">#endif</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span>
<a name="l00212"></a>00212         cout &lt;&lt; <span class="stringliteral">"\nSHA-512 validation suite running...\n\n"</span>;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 <span class="preprocessor">#ifdef WORD64_AVAILABLE</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span>        <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet512[] = 
<a name="l00216"></a>00216         {
<a name="l00217"></a>00217                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\xdd\xaf\x35\xa1\x93\x61\x7a\xba\xcc\x41\x73\x49\xae\x20\x41\x31\x12\xe6\xfa\x4e\x89\xa9\x7e\xa2\x0a\x9e\xee\xe6\x4b\x55\xd3\x9a\x21\x92\x99\x2a\x27\x4f\xc1\xa8\x36\xba\x3c\x23\xa3\xfe\xeb\xbd\x45\x4d\x44\x23\x64\x3c\xe8\x0e\x2a\x9a\xc9\x4f\xa5\x4c\xa4\x9f"</span>),
<a name="l00218"></a>00218                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"</span>, <span class="stringliteral">"\x8e\x95\x9b\x75\xda\xe3\x13\xda\x8c\xf4\xf7\x28\x14\xfc\x14\x3f\x8f\x77\x79\xc6\xeb\x9f\x7f\xa1\x72\x99\xae\xad\xb6\x88\x90\x18\x50\x1d\x28\x9e\x49\x00\xf7\xe4\x33\x1b\x99\xde\xc4\xb5\x43\x3a\xc7\xd3\x29\xee\xb6\xdd\x26\x54\x5e\x96\xe5\x5b\x87\x4b\xe9\x09"</span>),
<a name="l00219"></a>00219         };
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         <a class="code" href="class_s_h_a512.html" title="implements the SHA-512 standard">SHA512</a> sha512;
<a name="l00222"></a>00222         pass = HashModuleTest(sha512, testSet512, <span class="keyword">sizeof</span>(testSet512)/<span class="keyword">sizeof</span>(testSet512[0])) &amp;&amp; pass;
<a name="l00223"></a>00223 <span class="preprocessor">#else</span>
<a name="l00224"></a>00224 <span class="preprocessor"></span>        cout &lt;&lt; <span class="stringliteral">"word64 not available, skipping SHA-512 validation."</span> &lt;&lt; endl;
<a name="l00225"></a>00225 <span class="preprocessor">#endif</span>
<a name="l00226"></a>00226 <span class="preprocessor"></span>
<a name="l00227"></a>00227         <span class="keywordflow">return</span> pass;
<a name="l00228"></a>00228 }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="keywordtype">bool</span> ValidateTiger()
<a name="l00231"></a>00231 {
<a name="l00232"></a>00232         cout &lt;&lt; <span class="stringliteral">"\nTiger validation suite running...\n\n"</span>;
<a name="l00233"></a>00233 
<a name="l00234"></a>00234 <span class="preprocessor">#ifdef WORD64_AVAILABLE</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span>        <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] =
<a name="l00236"></a>00236         {
<a name="l00237"></a>00237                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">""</span>, <span class="stringliteral">"\x32\x93\xac\x63\x0c\x13\xf0\x24\x5f\x92\xbb\xb1\x76\x6e\x16\x16\x7a\x4e\x58\x49\x2d\xde\x73\xf3"</span>),
<a name="l00238"></a>00238                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\x2a\xab\x14\x84\xe8\xc1\x58\xf2\xbf\xb8\xc5\xff\x41\xb5\x7a\x52\x51\x29\x13\x1c\x95\x7b\x5f\x93"</span>),
<a name="l00239"></a>00239                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"Tiger"</span>, <span class="stringliteral">"\xdd\x00\x23\x07\x99\xf5\x00\x9f\xec\x6d\xeb\xc8\x38\xbb\x6a\x27\xdf\x2b\x9d\x6f\x11\x0c\x79\x37"</span>),
<a name="l00240"></a>00240                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-"</span>, <span class="stringliteral">"\xf7\x1c\x85\x83\x90\x2a\xfb\x87\x9e\xdf\xe6\x10\xf8\x2c\x0d\x47\x86\xa3\xa5\x34\x50\x44\x86\xb5"</span>),
<a name="l00241"></a>00241                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZ=abcdefghijklmnopqrstuvwxyz+0123456789"</span>, <span class="stringliteral">"\x48\xce\xeb\x63\x08\xb8\x7d\x46\xe9\x5d\x65\x61\x12\xcd\xf1\x8d\x97\x91\x5f\x97\x65\x65\x89\x57"</span>),
<a name="l00242"></a>00242                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"Tiger - A Fast New Hash Function, by Ross Anderson and Eli Biham"</span>, <span class="stringliteral">"\x8a\x86\x68\x29\x04\x0a\x41\x0c\x72\x9a\xd2\x3f\x5a\xda\x71\x16\x03\xb3\xcd\xd3\x57\xe4\xc1\x5e"</span>),
<a name="l00243"></a>00243                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"Tiger - A Fast New Hash Function, by Ross Anderson and Eli Biham, proceedings of Fast Software Encryption 3, Cambridge."</span>, <span class="stringliteral">"\xce\x55\xa6\xaf\xd5\x91\xf5\xeb\xac\x54\x7f\xf8\x4f\x89\x22\x7f\x93\x31\xda\xb0\xb6\x11\xc8\x89"</span>),
<a name="l00244"></a>00244                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"Tiger - A Fast New Hash Function, by Ross Anderson and Eli Biham, proceedings of Fast Software Encryption 3, Cambridge, 1996."</span>, <span class="stringliteral">"\x63\x1a\xbd\xd1\x03\xeb\x9a\x3d\x24\x5b\x6d\xfd\x4d\x77\xb2\x57\xfc\x74\x39\x50\x1d\x15\x68\xdd"</span>),
<a name="l00245"></a>00245                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-"</span>, <span class="stringliteral">"\xc5\x40\x34\xe5\xb4\x3e\xb8\x00\x58\x48\xa7\xe0\xae\x6a\xac\x76\xe4\xff\x59\x0a\xe7\x15\xfd\x25"</span>)
<a name="l00246"></a>00246         };
<a name="l00247"></a>00247 
<a name="l00248"></a>00248         <a class="code" href="class_tiger.html" title="Tiger">Tiger</a> tiger;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250         <span class="keywordflow">return</span> HashModuleTest(tiger, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0]));
<a name="l00251"></a>00251 <span class="preprocessor">#else</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span>        cout &lt;&lt; <span class="stringliteral">"word64 not available, skipping Tiger validation."</span> &lt;&lt; endl;
<a name="l00253"></a>00253         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00254"></a>00254 <span class="preprocessor">#endif</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span>}
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="keywordtype">bool</span> ValidateRIPEMD()
<a name="l00258"></a>00258 {
<a name="l00259"></a>00259         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet128[] = 
<a name="l00260"></a>00260         {
<a name="l00261"></a>00261                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">""</span>, <span class="stringliteral">"\xcd\xf2\x62\x13\xa1\x50\xdc\x3e\xcb\x61\x0f\x18\xf6\xb3\x8b\x46"</span>),
<a name="l00262"></a>00262                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"a"</span>, <span class="stringliteral">"\x86\xbe\x7a\xfa\x33\x9d\x0f\xc7\xcf\xc7\x85\xe7\x2f\x57\x8d\x33"</span>),
<a name="l00263"></a>00263                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\xc1\x4a\x12\x19\x9c\x66\xe4\xba\x84\x63\x6b\x0f\x69\x14\x4c\x77"</span>),
<a name="l00264"></a>00264                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"message digest"</span>, <span class="stringliteral">"\x9e\x32\x7b\x3d\x6e\x52\x30\x62\xaf\xc1\x13\x2d\x7d\xf9\xd1\xb8"</span>),
<a name="l00265"></a>00265                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdefghijklmnopqrstuvwxyz"</span>, <span class="stringliteral">"\xfd\x2a\xa6\x07\xf7\x1d\xc8\xf5\x10\x71\x49\x22\xb3\x71\x83\x4e"</span>),
<a name="l00266"></a>00266                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"</span>, <span class="stringliteral">"\xa1\xaa\x06\x89\xd0\xfa\xfa\x2d\xdc\x22\xe8\x8b\x49\x13\x3a\x06"</span>),
<a name="l00267"></a>00267                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>, <span class="stringliteral">"\xd1\xe9\x59\xeb\x17\x9c\x91\x1f\xae\xa4\x62\x4c\x60\xc5\xc7\x02"</span>),
<a name="l00268"></a>00268                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"12345678901234567890123456789012345678901234567890123456789012345678901234567890"</span>, <span class="stringliteral">"\x3f\x45\xef\x19\x47\x32\xc2\xdb\xb2\xc4\xa2\xc7\x69\x79\x5f\xa3"</span>),
<a name="l00269"></a>00269                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>, <span class="stringliteral">"\x4a\x7f\x57\x23\xf9\x54\xeb\xa1\x21\x6c\x9d\x8f\x63\x20\x43\x1f"</span>, 15625)
<a name="l00270"></a>00270         };
<a name="l00271"></a>00271 
<a name="l00272"></a>00272         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet160[] = 
<a name="l00273"></a>00273         {
<a name="l00274"></a>00274                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">""</span>, <span class="stringliteral">"\x9c\x11\x85\xa5\xc5\xe9\xfc\x54\x61\x28\x08\x97\x7e\xe8\xf5\x48\xb2\x25\x8d\x31"</span>),
<a name="l00275"></a>00275                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"a"</span>, <span class="stringliteral">"\x0b\xdc\x9d\x2d\x25\x6b\x3e\xe9\xda\xae\x34\x7b\xe6\xf4\xdc\x83\x5a\x46\x7f\xfe"</span>),
<a name="l00276"></a>00276                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\x8e\xb2\x08\xf7\xe0\x5d\x98\x7a\x9b\x04\x4a\x8e\x98\xc6\xb0\x87\xf1\x5a\x0b\xfc"</span>),
<a name="l00277"></a>00277                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"message digest"</span>, <span class="stringliteral">"\x5d\x06\x89\xef\x49\xd2\xfa\xe5\x72\xb8\x81\xb1\x23\xa8\x5f\xfa\x21\x59\x5f\x36"</span>),
<a name="l00278"></a>00278                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdefghijklmnopqrstuvwxyz"</span>, <span class="stringliteral">"\xf7\x1c\x27\x10\x9c\x69\x2c\x1b\x56\xbb\xdc\xeb\x5b\x9d\x28\x65\xb3\x70\x8d\xbc"</span>),
<a name="l00279"></a>00279                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"</span>, <span class="stringliteral">"\x12\xa0\x53\x38\x4a\x9c\x0c\x88\xe4\x05\xa0\x6c\x27\xdc\xf4\x9a\xda\x62\xeb\x2b"</span>),
<a name="l00280"></a>00280                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>, <span class="stringliteral">"\xb0\xe2\x0b\x6e\x31\x16\x64\x02\x86\xed\x3a\x87\xa5\x71\x30\x79\xb2\x1f\x51\x89"</span>),
<a name="l00281"></a>00281                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"12345678901234567890123456789012345678901234567890123456789012345678901234567890"</span>, <span class="stringliteral">"\x9b\x75\x2e\x45\x57\x3d\x4b\x39\xf4\xdb\xd3\x32\x3c\xab\x82\xbf\x63\x32\x6b\xfb"</span>),
<a name="l00282"></a>00282                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>, <span class="stringliteral">"\x52\x78\x32\x43\xc1\x69\x7b\xdb\xe1\x6d\x37\xf9\x7f\x68\xf0\x83\x25\xdc\x15\x28"</span>, 15625)
<a name="l00283"></a>00283         };
<a name="l00284"></a>00284 
<a name="l00285"></a>00285         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet256[] = 
<a name="l00286"></a>00286         {
<a name="l00287"></a>00287                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">""</span>, <span class="stringliteral">"\x02\xba\x4c\x4e\x5f\x8e\xcd\x18\x77\xfc\x52\xd6\x4d\x30\xe3\x7a\x2d\x97\x74\xfb\x1e\x5d\x02\x63\x80\xae\x01\x68\xe3\xc5\x52\x2d"</span>),
<a name="l00288"></a>00288                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"a"</span>, <span class="stringliteral">"\xf9\x33\x3e\x45\xd8\x57\xf5\xd9\x0a\x91\xba\xb7\x0a\x1e\xba\x0c\xfb\x1b\xe4\xb0\x78\x3c\x9a\xcf\xcd\x88\x3a\x91\x34\x69\x29\x25"</span>),
<a name="l00289"></a>00289                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\xaf\xbd\x6e\x22\x8b\x9d\x8c\xbb\xce\xf5\xca\x2d\x03\xe6\xdb\xa1\x0a\xc0\xbc\x7d\xcb\xe4\x68\x0e\x1e\x42\xd2\xe9\x75\x45\x9b\x65"</span>),
<a name="l00290"></a>00290                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"message digest"</span>, <span class="stringliteral">"\x87\xe9\x71\x75\x9a\x1c\xe4\x7a\x51\x4d\x5c\x91\x4c\x39\x2c\x90\x18\xc7\xc4\x6b\xc1\x44\x65\x55\x4a\xfc\xdf\x54\xa5\x07\x0c\x0e"</span>),
<a name="l00291"></a>00291                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdefghijklmnopqrstuvwxyz"</span>, <span class="stringliteral">"\x64\x9d\x30\x34\x75\x1e\xa2\x16\x77\x6b\xf9\xa1\x8a\xcc\x81\xbc\x78\x96\x11\x8a\x51\x97\x96\x87\x82\xdd\x1f\xd9\x7d\x8d\x51\x33"</span>),
<a name="l00292"></a>00292                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"</span>, <span class="stringliteral">"\x38\x43\x04\x55\x83\xaa\xc6\xc8\xc8\xd9\x12\x85\x73\xe7\xa9\x80\x9a\xfb\x2a\x0f\x34\xcc\xc3\x6e\xa9\xe7\x2f\x16\xf6\x36\x8e\x3f"</span>),
<a name="l00293"></a>00293                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>, <span class="stringliteral">"\x57\x40\xa4\x08\xac\x16\xb7\x20\xb8\x44\x24\xae\x93\x1c\xbb\x1f\xe3\x63\xd1\xd0\xbf\x40\x17\xf1\xa8\x9f\x7e\xa6\xde\x77\xa0\xb8"</span>),
<a name="l00294"></a>00294                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"12345678901234567890123456789012345678901234567890123456789012345678901234567890"</span>, <span class="stringliteral">"\x06\xfd\xcc\x7a\x40\x95\x48\xaa\xf9\x13\x68\xc0\x6a\x62\x75\xb5\x53\xe3\xf0\x99\xbf\x0e\xa4\xed\xfd\x67\x78\xdf\x89\xa8\x90\xdd"</span>),
<a name="l00295"></a>00295                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>, <span class="stringliteral">"\xac\x95\x37\x44\xe1\x0e\x31\x51\x4c\x15\x0d\x4d\x8d\x7b\x67\x73\x42\xe3\x33\x99\x78\x82\x96\xe4\x3a\xe4\x85\x0c\xe4\xf9\x79\x78"</span>, 15625)
<a name="l00296"></a>00296         };
<a name="l00297"></a>00297 
<a name="l00298"></a>00298         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet320[] = 
<a name="l00299"></a>00299         {
<a name="l00300"></a>00300                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">""</span>, <span class="stringliteral">"\x22\xd6\x5d\x56\x61\x53\x6c\xdc\x75\xc1\xfd\xf5\xc6\xde\x7b\x41\xb9\xf2\x73\x25\xeb\xc6\x1e\x85\x57\x17\x7d\x70\x5a\x0e\xc8\x80\x15\x1c\x3a\x32\xa0\x08\x99\xb8"</span>),
<a name="l00301"></a>00301                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"a"</span>, <span class="stringliteral">"\xce\x78\x85\x06\x38\xf9\x26\x58\xa5\xa5\x85\x09\x75\x79\x92\x6d\xda\x66\x7a\x57\x16\x56\x2c\xfc\xf6\xfb\xe7\x7f\x63\x54\x2f\x99\xb0\x47\x05\xd6\x97\x0d\xff\x5d"</span>),
<a name="l00302"></a>00302                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abc"</span>, <span class="stringliteral">"\xde\x4c\x01\xb3\x05\x4f\x89\x30\xa7\x9d\x09\xae\x73\x8e\x92\x30\x1e\x5a\x17\x08\x5b\xef\xfd\xc1\xb8\xd1\x16\x71\x3e\x74\xf8\x2f\xa9\x42\xd6\x4c\xdb\xc4\x68\x2d"</span>),
<a name="l00303"></a>00303                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"message digest"</span>, <span class="stringliteral">"\x3a\x8e\x28\x50\x2e\xd4\x5d\x42\x2f\x68\x84\x4f\x9d\xd3\x16\xe7\xb9\x85\x33\xfa\x3f\x2a\x91\xd2\x9f\x84\xd4\x25\xc8\x8d\x6b\x4e\xff\x72\x7d\xf6\x6a\x7c\x01\x97"</span>),
<a name="l00304"></a>00304                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdefghijklmnopqrstuvwxyz"</span>, <span class="stringliteral">"\xca\xbd\xb1\x81\x0b\x92\x47\x0a\x20\x93\xaa\x6b\xce\x05\x95\x2c\x28\x34\x8c\xf4\x3f\xf6\x08\x41\x97\x51\x66\xbb\x40\xed\x23\x40\x04\xb8\x82\x44\x63\xe6\xb0\x09"</span>),
<a name="l00305"></a>00305                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"</span>, <span class="stringliteral">"\xd0\x34\xa7\x95\x0c\xf7\x22\x02\x1b\xa4\xb8\x4d\xf7\x69\xa5\xde\x20\x60\xe2\x59\xdf\x4c\x9b\xb4\xa4\x26\x8c\x0e\x93\x5b\xbc\x74\x70\xa9\x69\xc9\xd0\x72\xa1\xac"</span>),
<a name="l00306"></a>00306                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>, <span class="stringliteral">"\xed\x54\x49\x40\xc8\x6d\x67\xf2\x50\xd2\x32\xc3\x0b\x7b\x3e\x57\x70\xe0\xc6\x0c\x8c\xb9\xa4\xca\xfe\x3b\x11\x38\x8a\xf9\x92\x0e\x1b\x99\x23\x0b\x84\x3c\x86\xa4"</span>),
<a name="l00307"></a>00307                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"12345678901234567890123456789012345678901234567890123456789012345678901234567890"</span>, <span class="stringliteral">"\x55\x78\x88\xaf\x5f\x6d\x8e\xd6\x2a\xb6\x69\x45\xc6\xd2\xa0\xa4\x7e\xcd\x53\x41\xe9\x15\xeb\x8f\xea\x1d\x05\x24\x95\x5f\x82\x5d\xc7\x17\xe4\xa0\x08\xab\x2d\x42"</span>),
<a name="l00308"></a>00308                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>, <span class="stringliteral">"\xbd\xee\x37\xf4\x37\x1e\x20\x64\x6b\x8b\x0d\x86\x2d\xda\x16\x29\x2a\xe3\x6f\x40\x96\x5e\x8c\x85\x09\xe6\x3d\x1d\xbd\xde\xcc\x50\x3e\x2b\x63\xeb\x92\x45\xbb\x66"</span>, 15625)
<a name="l00309"></a>00309         };
<a name="l00310"></a>00310 
<a name="l00311"></a>00311         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313         cout &lt;&lt; <span class="stringliteral">"\nRIPEMD-128 validation suite running...\n\n"</span>;
<a name="l00314"></a>00314         <a class="code" href="class_r_i_p_e_m_d128.html">RIPEMD128</a> md128;
<a name="l00315"></a>00315         pass = HashModuleTest(md128, testSet128, <span class="keyword">sizeof</span>(testSet128)/<span class="keyword">sizeof</span>(testSet128[0])) &amp;&amp; pass;
<a name="l00316"></a>00316 
<a name="l00317"></a>00317         cout &lt;&lt; <span class="stringliteral">"\nRIPEMD-160 validation suite running...\n\n"</span>;
<a name="l00318"></a>00318         <a class="code" href="class_r_i_p_e_m_d160.html" title="RIPEMD-160">RIPEMD160</a> md160;
<a name="l00319"></a>00319         pass = HashModuleTest(md160, testSet160, <span class="keyword">sizeof</span>(testSet160)/<span class="keyword">sizeof</span>(testSet160[0])) &amp;&amp; pass;
<a name="l00320"></a>00320 
<a name="l00321"></a>00321         cout &lt;&lt; <span class="stringliteral">"\nRIPEMD-256 validation suite running...\n\n"</span>;
<a name="l00322"></a>00322         <a class="code" href="class_r_i_p_e_m_d256.html">RIPEMD256</a> md256;
<a name="l00323"></a>00323         pass = HashModuleTest(md256, testSet256, <span class="keyword">sizeof</span>(testSet256)/<span class="keyword">sizeof</span>(testSet256[0])) &amp;&amp; pass;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325         cout &lt;&lt; <span class="stringliteral">"\nRIPEMD-320 validation suite running...\n\n"</span>;
<a name="l00326"></a>00326         <a class="code" href="class_r_i_p_e_m_d320.html">RIPEMD320</a> md320;
<a name="l00327"></a>00327         pass = HashModuleTest(md320, testSet320, <span class="keyword">sizeof</span>(testSet320)/<span class="keyword">sizeof</span>(testSet320[0])) &amp;&amp; pass;
<a name="l00328"></a>00328 
<a name="l00329"></a>00329         <span class="keywordflow">return</span> pass;
<a name="l00330"></a>00330 }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 <span class="preprocessor">#ifdef CRYPTOPP_REMOVED</span>
<a name="l00333"></a>00333 <span class="preprocessor"></span><span class="keywordtype">bool</span> ValidateHAVAL()
<a name="l00334"></a>00334 {
<a name="l00335"></a>00335         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00336"></a>00336         {
<a name="l00337"></a>00337                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">""</span>, <span class="stringliteral">"\xC6\x8F\x39\x91\x3F\x90\x1F\x3D\xDF\x44\xC7\x07\x35\x7A\x7D\x70"</span>),
<a name="l00338"></a>00338                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"a"</span>, <span class="stringliteral">"\x4D\xA0\x8F\x51\x4A\x72\x75\xDB\xC4\xCE\xCE\x4A\x34\x73\x85\x98\x39\x83\xA8\x30"</span>),
<a name="l00339"></a>00339                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"HAVAL"</span>, <span class="stringliteral">"\x0C\x13\x96\xD7\x77\x26\x89\xC4\x67\x73\xF3\xDA\xAC\xA4\xEF\xA9\x82\xAD\xBF\xB2\xF1\x46\x7E\xEA"</span>),
<a name="l00340"></a>00340                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"0123456789"</span>, <span class="stringliteral">"\xBE\xBD\x78\x16\xF0\x9B\xAE\xEC\xF8\x90\x3B\x1B\x9B\xC6\x72\xD9\xFA\x42\x8E\x46\x2B\xA6\x99\xF8\x14\x84\x15\x29"</span>),
<a name="l00341"></a>00341                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"abcdefghijklmnopqrstuvwxyz"</span>, <span class="stringliteral">"\xC9\xC7\xD8\xAF\xA1\x59\xFD\x9E\x96\x5C\xB8\x3F\xF5\xEE\x6F\x58\xAE\xDA\x35\x2C\x0E\xFF\x00\x55\x48\x15\x3A\x61\x55\x1C\x38\xEE"</span>),
<a name="l00342"></a>00342                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>, <span class="stringliteral">"\xB4\x5C\xB6\xE6\x2F\x2B\x13\x20\xE4\xF8\xF1\xB0\xB2\x73\xD4\x5A\xDD\x47\xC3\x21\xFD\x23\x99\x9D\xCF\x40\x3A\xC3\x76\x36\xD9\x63"</span>)
<a name="l00343"></a>00343         };
<a name="l00344"></a>00344 
<a name="l00345"></a>00345         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>;
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         cout &lt;&lt; <span class="stringliteral">"\nHAVAL validation suite running...\n\n"</span>;
<a name="l00348"></a>00348         {
<a name="l00349"></a>00349                 HAVAL3 md(16);
<a name="l00350"></a>00350                 pass = HashModuleTest(md, testSet+0, 1) &amp;&amp; pass;
<a name="l00351"></a>00351         }
<a name="l00352"></a>00352         {
<a name="l00353"></a>00353                 HAVAL3 md(20);
<a name="l00354"></a>00354                 pass = HashModuleTest(md, testSet+1, 1) &amp;&amp; pass;
<a name="l00355"></a>00355         }
<a name="l00356"></a>00356         {
<a name="l00357"></a>00357                 HAVAL4 md(24);
<a name="l00358"></a>00358                 pass = HashModuleTest(md, testSet+2, 1) &amp;&amp; pass;
<a name="l00359"></a>00359         }
<a name="l00360"></a>00360         {
<a name="l00361"></a>00361                 HAVAL4 md(28);
<a name="l00362"></a>00362                 pass = HashModuleTest(md, testSet+3, 1) &amp;&amp; pass;
<a name="l00363"></a>00363         }
<a name="l00364"></a>00364         {
<a name="l00365"></a>00365                 HAVAL5 md(32);
<a name="l00366"></a>00366                 pass = HashModuleTest(md, testSet+4, 1) &amp;&amp; pass;
<a name="l00367"></a>00367         }
<a name="l00368"></a>00368         {
<a name="l00369"></a>00369                 HAVAL5 md(32);
<a name="l00370"></a>00370                 pass = HashModuleTest(md, testSet+5, 1) &amp;&amp; pass;
<a name="l00371"></a>00371         }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373         <span class="keywordflow">return</span> pass;
<a name="l00374"></a>00374 }
<a name="l00375"></a>00375 <span class="preprocessor">#endif</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span>
<a name="l00377"></a>00377 <span class="keywordtype">bool</span> ValidatePanama()
<a name="l00378"></a>00378 {
<a name="l00379"></a>00379         cout &lt;&lt; <span class="stringliteral">"\nPanama validation suite running...\n"</span>;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381         <span class="keywordflow">return</span> RunTestDataFile(<span class="stringliteral">"TestVectors/panama.txt"</span>);
<a name="l00382"></a>00382 }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 <span class="keywordtype">bool</span> ValidateWhirlpool()
<a name="l00385"></a>00385 {
<a name="l00386"></a>00386         cout &lt;&lt; <span class="stringliteral">"\nWhirlpool Hash Function validation suite running...\n"</span>;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388 <span class="preprocessor">#ifdef WORD64_AVAILABLE</span>
<a name="l00389"></a>00389 <span class="preprocessor"></span>        <span class="keywordflow">return</span> RunTestDataFile(<span class="stringliteral">"TestVectors/whrlpool.txt"</span>);
<a name="l00390"></a>00390 <span class="preprocessor">#else</span>
<a name="l00391"></a>00391 <span class="preprocessor"></span>        cout &lt;&lt; <span class="stringliteral">"word64 not available, skipping Whirlpool validation."</span> &lt;&lt; endl;
<a name="l00392"></a>00392         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00393"></a>00393 <span class="preprocessor">#endif</span>
<a name="l00394"></a>00394 <span class="preprocessor"></span>}
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 <span class="preprocessor">#ifdef CRYPTOPP_REMOVED</span>
<a name="l00397"></a>00397 <span class="preprocessor"></span><span class="keywordtype">bool</span> ValidateMD5MAC()
<a name="l00398"></a>00398 {
<a name="l00399"></a>00399         <span class="keyword">const</span> byte keys[2][MD5MAC::KEYLENGTH]={
<a name="l00400"></a>00400                 {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff},
<a name="l00401"></a>00401                 {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10}};
<a name="l00402"></a>00402 
<a name="l00403"></a>00403         <span class="keyword">const</span> <span class="keywordtype">char</span> *TestVals[7]={
<a name="l00404"></a>00404                 <span class="stringliteral">""</span>,
<a name="l00405"></a>00405                 <span class="stringliteral">"a"</span>,
<a name="l00406"></a>00406                 <span class="stringliteral">"abc"</span>,
<a name="l00407"></a>00407                 <span class="stringliteral">"message digest"</span>,
<a name="l00408"></a>00408                 <span class="stringliteral">"abcdefghijklmnopqrstuvwxyz"</span>,
<a name="l00409"></a>00409                 <span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>,
<a name="l00410"></a>00410                 <span class="stringliteral">"12345678901234567890123456789012345678901234567890123456789012345678901234567890"</span>};
<a name="l00411"></a>00411 
<a name="l00412"></a>00412         <span class="keyword">const</span> byte output[2][7][MD5MAC::DIGESTSIZE]={
<a name="l00413"></a>00413                 {{0x1f,0x1e,0xf2,0x37,0x5c,0xc0,0xe0,0x84,0x4f,0x98,0xe7,0xe8,0x11,0xa3,0x4d,0xa8},
<a name="l00414"></a>00414                 {0x7a,0x76,0xee,0x64,0xca,0x71,0xef,0x23,0x7e,0x26,0x29,0xed,0x94,0x52,0x73,0x65},
<a name="l00415"></a>00415                 {0xe8,0x01,0x3c,0x11,0xf7,0x20,0x9d,0x13,0x28,0xc0,0xca,0xa0,0x4f,0xd0,0x12,0xa6},
<a name="l00416"></a>00416                 {0xc8,0x95,0x53,0x4f,0x22,0xa1,0x74,0xbc,0x3e,0x6a,0x25,0xa2,0xb2,0xef,0xd6,0x30},
<a name="l00417"></a>00417                 {0x91,0x72,0x86,0x7e,0xb6,0x00,0x17,0x88,0x4c,0x6f,0xa8,0xcc,0x88,0xeb,0xe7,0xc9},
<a name="l00418"></a>00418                 {0x3b,0xd0,0xe1,0x1d,0x5e,0x09,0x4c,0xb7,0x1e,0x35,0x44,0xac,0xa9,0xb8,0xbf,0xa2},
<a name="l00419"></a>00419                 {0x93,0x37,0x16,0x64,0x44,0xcc,0x95,0x35,0xb7,0xd5,0xb8,0x0f,0x91,0xe5,0x29,0xcb}},
<a name="l00420"></a>00420                 {{0x2f,0x6e,0x73,0x13,0xbf,0xbb,0xbf,0xcc,0x3a,0x2d,0xde,0x26,0x8b,0x59,0xcc,0x4d},
<a name="l00421"></a>00421                 {0x69,0xf6,0xca,0xff,0x40,0x25,0x36,0xd1,0x7a,0xe1,0x38,0x03,0x2c,0x0c,0x5f,0xfd},
<a name="l00422"></a>00422                 {0x56,0xd3,0x2b,0x6c,0x34,0x76,0x65,0xd9,0x74,0xd6,0xf7,0x5c,0x3f,0xc6,0xf0,0x40},
<a name="l00423"></a>00423                 {0xb8,0x02,0xb2,0x15,0x4e,0x59,0x8b,0x6f,0x87,0x60,0x56,0xc7,0x85,0x46,0x2c,0x0b},
<a name="l00424"></a>00424                 {0x5a,0xde,0xf4,0xbf,0xf8,0x04,0xbe,0x08,0x58,0x7e,0x94,0x41,0xcf,0x6d,0xbd,0x57},
<a name="l00425"></a>00425                 {0x18,0xe3,0x49,0xa5,0x24,0x44,0xb3,0x0e,0x5e,0xba,0x5a,0xdd,0xdc,0xd9,0xf1,0x8d},
<a name="l00426"></a>00426                 {0xf2,0xb9,0x06,0xa5,0xb8,0x4b,0x9b,0x4b,0xbe,0x95,0xed,0x32,0x56,0x4e,0xe7,0xeb}}};
<a name="l00427"></a>00427 
<a name="l00428"></a>00428         byte digest[MD5MAC::DIGESTSIZE];
<a name="l00429"></a>00429         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>, fail;
<a name="l00430"></a>00430 
<a name="l00431"></a>00431         cout &lt;&lt; <span class="stringliteral">"\nMD5MAC validation suite running...\n"</span>;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;2; k++)
<a name="l00434"></a>00434         {
<a name="l00435"></a>00435                 MD5MAC mac(keys[k]);
<a name="l00436"></a>00436                 cout &lt;&lt; <span class="stringliteral">"\nKEY: "</span>;
<a name="l00437"></a>00437                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;MD5MAC::KEYLENGTH;j++)
<a name="l00438"></a>00438                         cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">'0'</span>) &lt;&lt; hex &lt;&lt; (<span class="keywordtype">int</span>)keys[k][j];
<a name="l00439"></a>00439                 cout &lt;&lt; endl &lt;&lt; endl;
<a name="l00440"></a>00440                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;7;i++)
<a name="l00441"></a>00441                 {
<a name="l00442"></a>00442                         mac.Update((byte *)TestVals[i], strlen(TestVals[i]));
<a name="l00443"></a>00443                         mac.Final(digest);
<a name="l00444"></a>00444                         fail = memcmp(digest, output[k][i], MD5MAC::DIGESTSIZE)
<a name="l00445"></a>00445                                  || !mac.VerifyDigest(output[k][i], (byte *)TestVals[i], strlen(TestVals[i]));
<a name="l00446"></a>00446                         pass = pass &amp;&amp; !fail;
<a name="l00447"></a>00447                         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED   "</span> : <span class="stringliteral">"passed   "</span>);
<a name="l00448"></a>00448                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;MD5MAC::DIGESTSIZE;j++)
<a name="l00449"></a>00449                                 cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">'0'</span>) &lt;&lt; hex &lt;&lt; (<span class="keywordtype">int</span>)digest[j];
<a name="l00450"></a>00450                         cout &lt;&lt; <span class="stringliteral">"   \""</span> &lt;&lt; TestVals[i] &lt;&lt; <span class="charliteral">'\"'</span> &lt;&lt; endl;
<a name="l00451"></a>00451                 }
<a name="l00452"></a>00452         }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454         <span class="keywordflow">return</span> pass;
<a name="l00455"></a>00455 }
<a name="l00456"></a>00456 <span class="preprocessor">#endif</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span>
<a name="l00458"></a>00458 <span class="keywordtype">bool</span> ValidateHMAC()
<a name="l00459"></a>00459 {
<a name="l00460"></a>00460         <span class="keyword">typedef</span> <a class="code" href="class_h_m_a_c.html" title="HMAC">HMAC&lt;Weak::MD5&gt;</a> HMAC_MD5;
<a name="l00461"></a>00461 
<a name="l00462"></a>00462         <span class="keyword">const</span> <span class="keywordtype">char</span>* keys[]=
<a name="l00463"></a>00463         {
<a name="l00464"></a>00464                 <span class="stringliteral">"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"</span>,
<a name="l00465"></a>00465                 <span class="stringliteral">"Jefe"</span>,
<a name="l00466"></a>00466                 <span class="stringliteral">"\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"</span>,
<a name="l00467"></a>00467                 <span class="stringliteral">"\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"</span>
<a name="l00468"></a>00468                         <span class="stringliteral">"\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"</span>
<a name="l00469"></a>00469                         <span class="stringliteral">"\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"</span>
<a name="l00470"></a>00470                         <span class="stringliteral">"\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"</span>
<a name="l00471"></a>00471                         <span class="stringliteral">"\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"</span>
<a name="l00472"></a>00472         };
<a name="l00473"></a>00473 
<a name="l00474"></a>00474         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00475"></a>00475         {
<a name="l00476"></a>00476                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"Hi There"</span>, <span class="stringliteral">"\x92\x94\x72\x7a\x36\x38\xbb\x1c\x13\xf4\x8e\xf8\x15\x8b\xfc\x9d"</span>),
<a name="l00477"></a>00477                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"what do ya want for nothing?"</span>, <span class="stringliteral">"\x75\x0c\x78\x3e\x6a\xb0\xb5\x03\xea\xa8\x6e\x31\x0a\x5d\xb7\x38"</span>),
<a name="l00478"></a>00478                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"</span>,
<a name="l00479"></a>00479                         <span class="stringliteral">"\x56\xbe\x34\x52\x1d\x14\x4c\x88\xdb\xb8\xc7\x33\xf0\xe8\xb3\xf6"</span>),
<a name="l00480"></a>00480                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">"Test Using Larger Than Block-Size Key - Hash Key First"</span>, <span class="stringliteral">"\x6b\x1a\xb7\xfe\x4b\xd7\xbf\x8f\x0b\x62\xe6\xce\x61\xb9\xd0\xcd"</span>)
<a name="l00481"></a>00481         };
<a name="l00482"></a>00482 
<a name="l00483"></a>00483         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>;
<a name="l00484"></a>00484 
<a name="l00485"></a>00485         cout &lt;&lt; <span class="stringliteral">"\nHMAC/MD5 validation suite running...\n"</span>;
<a name="l00486"></a>00486 
<a name="l00487"></a>00487         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;4; k++)
<a name="l00488"></a>00488         {
<a name="l00489"></a>00489                 HMAC_MD5 mac((byte *)keys[k], strlen(keys[k]));
<a name="l00490"></a>00490                 cout &lt;&lt; <span class="stringliteral">"\nKEY: "</span>;
<a name="l00491"></a>00491                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; keys[k][j] != 0; j++)
<a name="l00492"></a>00492                         cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">'0'</span>) &lt;&lt; hex &lt;&lt; (<span class="keywordtype">int</span>)(byte)keys[k][j];
<a name="l00493"></a>00493                 cout &lt;&lt; endl;
<a name="l00494"></a>00494 
<a name="l00495"></a>00495                 pass = HashModuleTest(mac, testSet+k, 1) &amp;&amp; pass;
<a name="l00496"></a>00496         }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498         <span class="keywordflow">return</span> pass;
<a name="l00499"></a>00499 }
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 <span class="preprocessor">#ifdef CRYPTOPP_REMOVED</span>
<a name="l00502"></a>00502 <span class="preprocessor"></span><span class="keywordtype">bool</span> ValidateXMACC()
<a name="l00503"></a>00503 {
<a name="l00504"></a>00504         <span class="keyword">typedef</span> XMACC&lt;MD5&gt; XMACC_MD5;
<a name="l00505"></a>00505 
<a name="l00506"></a>00506         <span class="keyword">const</span> byte keys[2][XMACC_MD5::KEYLENGTH]={
<a name="l00507"></a>00507                 {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb},
<a name="l00508"></a>00508                 {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98}};
<a name="l00509"></a>00509 
<a name="l00510"></a>00510         <span class="keyword">const</span> word32 counters[2]={0xccddeeff, 0x76543210};
<a name="l00511"></a>00511 
<a name="l00512"></a>00512         <span class="keyword">const</span> <span class="keywordtype">char</span> *TestVals[7]={
<a name="l00513"></a>00513                 <span class="stringliteral">""</span>,
<a name="l00514"></a>00514                 <span class="stringliteral">"a"</span>,
<a name="l00515"></a>00515                 <span class="stringliteral">"abc"</span>,
<a name="l00516"></a>00516                 <span class="stringliteral">"message digest"</span>,
<a name="l00517"></a>00517                 <span class="stringliteral">"abcdefghijklmnopqrstuvwxyz"</span>,
<a name="l00518"></a>00518                 <span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>,
<a name="l00519"></a>00519                 <span class="stringliteral">"12345678901234567890123456789012345678901234567890123456789012345678901234567890"</span>};
<a name="l00520"></a>00520 
<a name="l00521"></a>00521         <span class="keyword">const</span> byte output[2][7][XMACC_MD5::DIGESTSIZE]={
<a name="l00522"></a>00522                 {{0xcc,0xdd,0xef,0x00,0xfa,0x89,0x54,0x92,0x86,0x32,0xda,0x2a,0x3f,0x29,0xc5,0x52,0xa0,0x0d,0x05,0x13},
<a name="l00523"></a>00523                 {0xcc,0xdd,0xef,0x01,0xae,0xdb,0x8b,0x7b,0x69,0x71,0xc7,0x91,0x71,0x48,0x9d,0x18,0xe7,0xdf,0x9d,0x5a},
<a name="l00524"></a>00524                 {0xcc,0xdd,0xef,0x02,0x5e,0x01,0x2e,0x2e,0x4b,0xc3,0x83,0x62,0xc2,0xf4,0xe6,0x18,0x1c,0x44,0xaf,0xca},
<a name="l00525"></a>00525                 {0xcc,0xdd,0xef,0x03,0x3e,0xa9,0xf1,0xe0,0x97,0x91,0xf8,0xe2,0xbe,0xe0,0xdf,0xf3,0x41,0x03,0xb3,0x5a},
<a name="l00526"></a>00526                 {0xcc,0xdd,0xef,0x04,0x2e,0x6a,0x8d,0xb9,0x72,0xe3,0xce,0x9f,0xf4,0x28,0x45,0xe7,0xbc,0x80,0xa9,0xc7},
<a name="l00527"></a>00527                 {0xcc,0xdd,0xef,0x05,0x1a,0xd5,0x40,0x78,0xfb,0x16,0x37,0xfc,0x7a,0x1d,0xce,0xb4,0x77,0x10,0xb2,0xa0},
<a name="l00528"></a>00528                 {0xcc,0xdd,0xef,0x06,0x13,0x2f,0x11,0x47,0xd7,0x1b,0xb5,0x52,0x36,0x51,0x26,0xb0,0x96,0xd7,0x60,0x81}},
<a name="l00529"></a>00529                 {{0x76,0x54,0x32,0x11,0xe9,0xcb,0x74,0x32,0x07,0x93,0xfe,0x01,0xdd,0x27,0xdb,0xde,0x6b,0x77,0xa4,0x56},
<a name="l00530"></a>00530                 {0x76,0x54,0x32,0x12,0xcd,0x55,0x87,0x5c,0xc0,0x35,0x85,0x99,0x44,0x02,0xa5,0x0b,0x8c,0xe7,0x2c,0x68},
<a name="l00531"></a>00531                 {0x76,0x54,0x32,0x13,0xac,0xfd,0x87,0x50,0xc3,0x8f,0xcd,0x58,0xaa,0xa5,0x7e,0x7a,0x25,0x63,0x26,0xd1},
<a name="l00532"></a>00532                 {0x76,0x54,0x32,0x14,0xe3,0x30,0xf5,0xdd,0x27,0x2b,0x76,0x22,0x7f,0xaa,0x90,0x73,0x6a,0x48,0xdb,0x00},
<a name="l00533"></a>00533                 {0x76,0x54,0x32,0x15,0xfc,0x57,0x00,0x20,0x7c,0x9d,0xf6,0x30,0x6f,0xbd,0x46,0x3e,0xfb,0x8a,0x2c,0x60},
<a name="l00534"></a>00534                 {0x76,0x54,0x32,0x16,0xfb,0x0f,0xd3,0xdf,0x4c,0x4b,0xc3,0x05,0x9d,0x63,0x1e,0xba,0x25,0x2b,0xbe,0x35},
<a name="l00535"></a>00535                 {0x76,0x54,0x32,0x17,0xc6,0xfe,0xe6,0x5f,0xb1,0x35,0x8a,0xf5,0x32,0x7a,0x80,0xbd,0xb8,0x72,0xee,0xae}}};
<a name="l00536"></a>00536 
<a name="l00537"></a>00537         byte digest[XMACC_MD5::DIGESTSIZE];
<a name="l00538"></a>00538         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>, fail;
<a name="l00539"></a>00539 
<a name="l00540"></a>00540         cout &lt;&lt; <span class="stringliteral">"\nXMACC/MD5 validation suite running...\n"</span>;
<a name="l00541"></a>00541 
<a name="l00542"></a>00542         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;2; k++)
<a name="l00543"></a>00543         {
<a name="l00544"></a>00544                 XMACC_MD5 mac(keys[k], counters[k]);
<a name="l00545"></a>00545                 cout &lt;&lt; <span class="stringliteral">"\nKEY: "</span>;
<a name="l00546"></a>00546                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;XMACC_MD5::KEYLENGTH;j++)
<a name="l00547"></a>00547                         cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">'0'</span>) &lt;&lt; hex &lt;&lt; (<span class="keywordtype">int</span>)keys[k][j];
<a name="l00548"></a>00548                 cout &lt;&lt; <span class="stringliteral">"    COUNTER: 0x"</span> &lt;&lt; hex &lt;&lt; counters[k] &lt;&lt; endl &lt;&lt; endl;
<a name="l00549"></a>00549                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;7;i++)
<a name="l00550"></a>00550                 {
<a name="l00551"></a>00551                         mac.Update((byte *)TestVals[i], strlen(TestVals[i]));
<a name="l00552"></a>00552                         mac.Final(digest);
<a name="l00553"></a>00553                         fail = memcmp(digest, output[k][i], XMACC_MD5::DIGESTSIZE)
<a name="l00554"></a>00554                                  || !mac.VerifyDigest(output[k][i], (byte *)TestVals[i], strlen(TestVals[i]));
<a name="l00555"></a>00555                         pass = pass &amp;&amp; !fail;
<a name="l00556"></a>00556                         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED   "</span> : <span class="stringliteral">"passed   "</span>);
<a name="l00557"></a>00557                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;XMACC_MD5::DIGESTSIZE;j++)
<a name="l00558"></a>00558                                 cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">'0'</span>) &lt;&lt; hex &lt;&lt; (<span class="keywordtype">int</span>)digest[j];
<a name="l00559"></a>00559                         cout &lt;&lt; <span class="stringliteral">"   \""</span> &lt;&lt; TestVals[i] &lt;&lt; <span class="charliteral">'\"'</span> &lt;&lt; endl;
<a name="l00560"></a>00560                 }
<a name="l00561"></a>00561         }
<a name="l00562"></a>00562 
<a name="l00563"></a>00563         <span class="keywordflow">return</span> pass;
<a name="l00564"></a>00564 }
<a name="l00565"></a>00565 <span class="preprocessor">#endif</span>
<a name="l00566"></a>00566 <span class="preprocessor"></span>
<a name="l00567"></a>00567 <span class="keywordtype">bool</span> ValidateTTMAC()
<a name="l00568"></a>00568 {
<a name="l00569"></a>00569         <span class="keyword">const</span> byte key[<a class="code" href="class_fixed_key_length.html#b994d881a105849f64a973373e8f282c">TTMAC::KEYLENGTH</a>]={
<a name="l00570"></a>00570                 0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,
<a name="l00571"></a>00571                 0xaa,0xbb,0xcc,0xdd,0xee,0xff,0x01,0x23,0x45,0x67};
<a name="l00572"></a>00572 
<a name="l00573"></a>00573         <span class="keyword">const</span> <span class="keywordtype">char</span> *TestVals[8]={
<a name="l00574"></a>00574                 <span class="stringliteral">""</span>,
<a name="l00575"></a>00575                 <span class="stringliteral">"a"</span>,
<a name="l00576"></a>00576                 <span class="stringliteral">"abc"</span>,
<a name="l00577"></a>00577                 <span class="stringliteral">"message digest"</span>,
<a name="l00578"></a>00578                 <span class="stringliteral">"abcdefghijklmnopqrstuvwxyz"</span>,
<a name="l00579"></a>00579                 <span class="stringliteral">"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"</span>,
<a name="l00580"></a>00580                 <span class="stringliteral">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>,
<a name="l00581"></a>00581                 <span class="stringliteral">"12345678901234567890123456789012345678901234567890123456789012345678901234567890"</span>};
<a name="l00582"></a>00582 
<a name="l00583"></a>00583         <span class="keyword">const</span> byte output[8][<a class="code" href="class_t_t_m_a_c___base.html#e82f65af091adcea740c399e31f6c17c">TTMAC::DIGESTSIZE</a>]={
<a name="l00584"></a>00584                 {0x2d,0xec,0x8e,0xd4,0xa0,0xfd,0x71,0x2e,0xd9,0xfb,0xf2,0xab,0x46,0x6e,0xc2,0xdf,0x21,0x21,0x5e,0x4a},
<a name="l00585"></a>00585                 {0x58,0x93,0xe3,0xe6,0xe3,0x06,0x70,0x4d,0xd7,0x7a,0xd6,0xe6,0xed,0x43,0x2c,0xde,0x32,0x1a,0x77,0x56},
<a name="l00586"></a>00586                 {0x70,0xbf,0xd1,0x02,0x97,0x97,0xa5,0xc1,0x6d,0xa5,0xb5,0x57,0xa1,0xf0,0xb2,0x77,0x9b,0x78,0x49,0x7e},
<a name="l00587"></a>00587                 {0x82,0x89,0xf4,0xf1,0x9f,0xfe,0x4f,0x2a,0xf7,0x37,0xde,0x4b,0xd7,0x1c,0x82,0x9d,0x93,0xa9,0x72,0xfa},
<a name="l00588"></a>00588                 {0x21,0x86,0xca,0x09,0xc5,0x53,0x31,0x98,0xb7,0x37,0x1f,0x24,0x52,0x73,0x50,0x4c,0xa9,0x2b,0xae,0x60},
<a name="l00589"></a>00589                 {0x8a,0x7b,0xf7,0x7a,0xef,0x62,0xa2,0x57,0x84,0x97,0xa2,0x7c,0x0d,0x65,0x18,0xa4,0x29,0xe7,0xc1,0x4d},
<a name="l00590"></a>00590                 {0x54,0xba,0xc3,0x92,0xa8,0x86,0x80,0x6d,0x16,0x95,0x56,0xfc,0xbb,0x67,0x89,0xb5,0x4f,0xb3,0x64,0xfb},
<a name="l00591"></a>00591                 {0x0c,0xed,0x2c,0x9f,0x8f,0x0d,0x9d,0x03,0x98,0x1a,0xb5,0xc8,0x18,0x4b,0xac,0x43,0xdd,0x54,0xc4,0x84}};
<a name="l00592"></a>00592 
<a name="l00593"></a>00593         byte digest[<a class="code" href="class_t_t_m_a_c___base.html#e82f65af091adcea740c399e31f6c17c">TTMAC::DIGESTSIZE</a>];
<a name="l00594"></a>00594         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>, fail;
<a name="l00595"></a>00595 
<a name="l00596"></a>00596         cout &lt;&lt; <span class="stringliteral">"\nTwo-Track-MAC validation suite running...\n"</span>;
<a name="l00597"></a>00597 
<a name="l00598"></a>00598         <a class="code" href="class_t_t_m_a_c.html" title="Two-Track-MAC">TTMAC</a> mac(key, <span class="keyword">sizeof</span>(key));
<a name="l00599"></a>00599         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;<span class="keyword">sizeof</span>(TestVals)/<span class="keyword">sizeof</span>(TestVals[0]); k++)
<a name="l00600"></a>00600         {
<a name="l00601"></a>00601                 mac.Update((byte *)TestVals[k], strlen(TestVals[k]));
<a name="l00602"></a>00602                 mac.Final(digest);
<a name="l00603"></a>00603                 fail = memcmp(digest, output[k], <a class="code" href="class_t_t_m_a_c___base.html#e82f65af091adcea740c399e31f6c17c">TTMAC::DIGESTSIZE</a>)
<a name="l00604"></a>00604                         || !mac.VerifyDigest(output[k], (byte *)TestVals[k], strlen(TestVals[k]));
<a name="l00605"></a>00605                 pass = pass &amp;&amp; !fail;
<a name="l00606"></a>00606                 cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED   "</span> : <span class="stringliteral">"passed   "</span>);
<a name="l00607"></a>00607                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;<a class="code" href="class_t_t_m_a_c___base.html#e82f65af091adcea740c399e31f6c17c">TTMAC::DIGESTSIZE</a>;j++)
<a name="l00608"></a>00608                         cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">'0'</span>) &lt;&lt; hex &lt;&lt; (<span class="keywordtype">int</span>)digest[j];
<a name="l00609"></a>00609                 cout &lt;&lt; <span class="stringliteral">"   \""</span> &lt;&lt; TestVals[k] &lt;&lt; <span class="charliteral">'\"'</span> &lt;&lt; endl;
<a name="l00610"></a>00610         }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00613"></a>00613 }
<a name="l00614"></a>00614 
<a name="l00615"></a><a class="code" href="struct_p_b_k_d_f___test_tuple.html">00615</a> <span class="keyword">struct </span><a class="code" href="struct_p_b_k_d_f___test_tuple.html">PBKDF_TestTuple</a>
<a name="l00616"></a>00616 {
<a name="l00617"></a><a class="code" href="struct_p_b_k_d_f___test_tuple.html#97ffe0525b3a3fbea8a9ba7c682812c5">00617</a>         byte <a class="code" href="struct_p_b_k_d_f___test_tuple.html#97ffe0525b3a3fbea8a9ba7c682812c5">purpose</a>;
<a name="l00618"></a><a class="code" href="struct_p_b_k_d_f___test_tuple.html#67d9e42de826b700781e326965b35de5">00618</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="struct_p_b_k_d_f___test_tuple.html#67d9e42de826b700781e326965b35de5">iterations</a>;
<a name="l00619"></a><a class="code" href="struct_p_b_k_d_f___test_tuple.html#352e68638b724c8ec888301f618b122b">00619</a>         <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="struct_p_b_k_d_f___test_tuple.html#8904fbadd7100d350d8e4c447f7e0ee9">hexPassword</a>, *<a class="code" href="struct_p_b_k_d_f___test_tuple.html#352e68638b724c8ec888301f618b122b">hexSalt</a>, *<a class="code" href="struct_p_b_k_d_f___test_tuple.html#a340ec45ce1558bc4b349e1071b85d42">hexDerivedKey</a>;
<a name="l00620"></a>00620 };
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 <span class="keywordtype">bool</span> TestPBKDF(<a class="code" href="class_password_based_key_derivation_function.html" title="abstract base class for password based key derivation function">PasswordBasedKeyDerivationFunction</a> &amp;pbkdf, <span class="keyword">const</span> <a class="code" href="struct_p_b_k_d_f___test_tuple.html">PBKDF_TestTuple</a> *testSet, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> testSetSize)
<a name="l00623"></a>00623 {
<a name="l00624"></a>00624         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;testSetSize; i++)
<a name="l00627"></a>00627         {
<a name="l00628"></a>00628                 <span class="keyword">const</span> <a class="code" href="struct_p_b_k_d_f___test_tuple.html">PBKDF_TestTuple</a> &amp;tuple = testSet[i];
<a name="l00629"></a>00629 
<a name="l00630"></a>00630                 <span class="keywordtype">string</span> password, salt, derivedKey;
<a name="l00631"></a>00631                 <a class="code" href="class_string_source.html" title="string-based implementation of Source interface">StringSource</a>(tuple.hexPassword, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>(<span class="keyword">new</span> <a class="code" href="class_string_sink_template.html" title="Append input to a string object.">StringSink</a>(password)));
<a name="l00632"></a>00632                 <a class="code" href="class_string_source.html" title="string-based implementation of Source interface">StringSource</a>(tuple.hexSalt, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>(<span class="keyword">new</span> <a class="code" href="class_string_sink_template.html" title="Append input to a string object.">StringSink</a>(salt)));
<a name="l00633"></a>00633                 <a class="code" href="class_string_source.html" title="string-based implementation of Source interface">StringSource</a>(tuple.hexDerivedKey, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>(<span class="keyword">new</span> <a class="code" href="class_string_sink_template.html" title="Append input to a string object.">StringSink</a>(derivedKey)));
<a name="l00634"></a>00634 
<a name="l00635"></a>00635                 <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> derived(derivedKey.size());
<a name="l00636"></a>00636                 pbkdf.<a class="code" href="class_password_based_key_derivation_function.html#eaff60e52adddbaf6abd9ff2b64f5356" title="derive key from password">DeriveKey</a>(derived, derived.size(), tuple.purpose, (byte *)password.data(), password.size(), (byte *)salt.data(), salt.size(), tuple.iterations);
<a name="l00637"></a>00637                 <span class="keywordtype">bool</span> fail = memcmp(derived, derivedKey.data(), derived.size()) != 0;
<a name="l00638"></a>00638                 pass = pass &amp;&amp; !fail;
<a name="l00639"></a>00639 
<a name="l00640"></a>00640                 <a class="code" href="class_hex_encoder.html" title="Converts given data to base 16.">HexEncoder</a> enc(<span class="keyword">new</span> <a class="code" href="class_file_sink.html" title="file-based implementation of Sink interface">FileSink</a>(cout));
<a name="l00641"></a>00641                 cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED   "</span> : <span class="stringliteral">"passed   "</span>);
<a name="l00642"></a>00642                 enc.<a class="code" href="class_buffered_transformation.html#e70658b0d271f8e114ac6c3cc9774ede" title="input a byte for processing">Put</a>(tuple.purpose);
<a name="l00643"></a>00643                 cout &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; tuple.iterations;
<a name="l00644"></a>00644                 cout &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; tuple.hexPassword &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; tuple.hexSalt &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l00645"></a>00645                 enc.<a class="code" href="class_buffered_transformation.html#e70658b0d271f8e114ac6c3cc9774ede" title="input a byte for processing">Put</a>(derived, derived.size());
<a name="l00646"></a>00646                 cout &lt;&lt; endl;
<a name="l00647"></a>00647         }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649         <span class="keywordflow">return</span> pass;
<a name="l00650"></a>00650 }
<a name="l00651"></a>00651 
<a name="l00652"></a>00652 <span class="keywordtype">bool</span> ValidatePBKDF()
<a name="l00653"></a>00653 {
<a name="l00654"></a>00654         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>;
<a name="l00655"></a>00655 
<a name="l00656"></a>00656         {
<a name="l00657"></a>00657         <span class="comment">// from OpenSSL PKCS#12 Program FAQ v1.77, at http://www.drh-consultancy.demon.co.uk/test.txt</span>
<a name="l00658"></a>00658         <a class="code" href="struct_p_b_k_d_f___test_tuple.html">PBKDF_TestTuple</a> testSet[] = 
<a name="l00659"></a>00659         {
<a name="l00660"></a>00660                 {1, 1, <span class="stringliteral">"0073006D006500670000"</span>, <span class="stringliteral">"0A58CF64530D823F"</span>, <span class="stringliteral">"8AAAE6297B6CB04642AB5B077851284EB7128F1A2A7FBCA3"</span>},
<a name="l00661"></a>00661                 {2, 1, <span class="stringliteral">"0073006D006500670000"</span>, <span class="stringliteral">"0A58CF64530D823F"</span>, <span class="stringliteral">"79993DFE048D3B76"</span>},
<a name="l00662"></a>00662                 {1, 1, <span class="stringliteral">"0073006D006500670000"</span>, <span class="stringliteral">"642B99AB44FB4B1F"</span>, <span class="stringliteral">"F3A95FEC48D7711E985CFE67908C5AB79FA3D7C5CAA5D966"</span>},
<a name="l00663"></a>00663                 {2, 1, <span class="stringliteral">"0073006D006500670000"</span>, <span class="stringliteral">"642B99AB44FB4B1F"</span>, <span class="stringliteral">"C0A38D64A79BEA1D"</span>},
<a name="l00664"></a>00664                 {3, 1, <span class="stringliteral">"0073006D006500670000"</span>, <span class="stringliteral">"3D83C0E4546AC140"</span>, <span class="stringliteral">"8D967D88F6CAA9D714800AB3D48051D63F73A312"</span>},
<a name="l00665"></a>00665                 {1, 1000, <span class="stringliteral">"007100750065006500670000"</span>, <span class="stringliteral">"05DEC959ACFF72F7"</span>, <span class="stringliteral">"ED2034E36328830FF09DF1E1A07DD357185DAC0D4F9EB3D4"</span>},
<a name="l00666"></a>00666                 {2, 1000, <span class="stringliteral">"007100750065006500670000"</span>, <span class="stringliteral">"05DEC959ACFF72F7"</span>, <span class="stringliteral">"11DEDAD7758D4860"</span>},
<a name="l00667"></a>00667                 {1, 1000, <span class="stringliteral">"007100750065006500670000"</span>, <span class="stringliteral">"1682C0FC5B3F7EC5"</span>, <span class="stringliteral">"483DD6E919D7DE2E8E648BA8F862F3FBFBDC2BCB2C02957F"</span>},
<a name="l00668"></a>00668                 {2, 1000, <span class="stringliteral">"007100750065006500670000"</span>, <span class="stringliteral">"1682C0FC5B3F7EC5"</span>, <span class="stringliteral">"9D461D1B00355C50"</span>},
<a name="l00669"></a>00669                 {3, 1000, <span class="stringliteral">"007100750065006500670000"</span>, <span class="stringliteral">"263216FCC2FAB31C"</span>, <span class="stringliteral">"5EC4C7A80DF652294C3925B6489A7AB857C83476"</span>}
<a name="l00670"></a>00670         };
<a name="l00671"></a>00671 
<a name="l00672"></a>00672         <a class="code" href="class_p_k_c_s12___p_b_k_d_f.html" title="PBKDF from PKCS #12, appendix B, T should be a HashTransformation class.">PKCS12_PBKDF&lt;SHA1&gt;</a> pbkdf;
<a name="l00673"></a>00673 
<a name="l00674"></a>00674         cout &lt;&lt; <span class="stringliteral">"\nPKCS #12 PBKDF validation suite running...\n\n"</span>;
<a name="l00675"></a>00675         pass = TestPBKDF(pbkdf, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0])) &amp;&amp; pass;
<a name="l00676"></a>00676         }
<a name="l00677"></a>00677 
<a name="l00678"></a>00678         {
<a name="l00679"></a>00679         <span class="comment">// from draft-ietf-smime-password-03.txt, at http://www.imc.org/draft-ietf-smime-password</span>
<a name="l00680"></a>00680         <a class="code" href="struct_p_b_k_d_f___test_tuple.html">PBKDF_TestTuple</a> testSet[] = 
<a name="l00681"></a>00681         {
<a name="l00682"></a>00682                 {0, 5, <span class="stringliteral">"70617373776f7264"</span>, <span class="stringliteral">"1234567878563412"</span>, <span class="stringliteral">"D1DAA78615F287E6"</span>},
<a name="l00683"></a>00683                 {0, 500, <span class="stringliteral">"416C6C206E2D656E746974696573206D75737420636F6D6D756E69636174652077697468206F74686572206E2d656E74697469657320766961206E2D3120656E746974656568656568656573"</span>, <span class="stringliteral">"1234567878563412"</span>,<span class="stringliteral">"6A8970BF68C92CAEA84A8DF28510858607126380CC47AB2D"</span>}
<a name="l00684"></a>00684         };
<a name="l00685"></a>00685 
<a name="l00686"></a>00686         <a class="code" href="class_p_k_c_s5___p_b_k_d_f2___h_m_a_c.html" title="PBKDF2 from PKCS #5, T should be a HashTransformation class.">PKCS5_PBKDF2_HMAC&lt;SHA1&gt;</a> pbkdf;
<a name="l00687"></a>00687 
<a name="l00688"></a>00688         cout &lt;&lt; <span class="stringliteral">"\nPKCS #5 PBKDF2 validation suite running...\n\n"</span>;
<a name="l00689"></a>00689         pass = TestPBKDF(pbkdf, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0])) &amp;&amp; pass;
<a name="l00690"></a>00690         }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692         <span class="keywordflow">return</span> pass;
<a name="l00693"></a>00693 }
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 11:11:25 2007 for Crypto++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
