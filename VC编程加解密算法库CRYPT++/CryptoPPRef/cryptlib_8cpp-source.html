<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Crypto++: cryptlib.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>cryptlib.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// cryptlib.cpp - written and placed in the public domain by Wei Dai</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include "pch.h"</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="preprocessor">#ifndef CRYPTOPP_IMPORTS</span>
<a name="l00006"></a>00006 <span class="preprocessor"></span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "<a class="code" href="cryptlib_8h.html">cryptlib.h</a>"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "misc.h"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "filters.h"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "algparam.h"</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "<a class="code" href="fips140_8h.html">fips140.h</a>"</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include "argnames.h"</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include "fltrimpl.h"</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include "trdlocal.h"</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include "osrng.h"</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 NAMESPACE_BEGIN(CryptoPP)
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 CRYPTOPP_COMPILE_ASSERT(sizeof(byte) == 1);
<a name="l00022"></a>00022 CRYPTOPP_COMPILE_ASSERT(sizeof(word16) == 2);
<a name="l00023"></a>00023 CRYPTOPP_COMPILE_ASSERT(sizeof(word32) == 4);
<a name="l00024"></a>00024 <span class="preprocessor">#ifdef WORD64_AVAILABLE</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span>CRYPTOPP_COMPILE_ASSERT(<span class="keyword">sizeof</span>(word64) == 8);
<a name="l00026"></a>00026 <span class="preprocessor">#endif</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#ifdef CRYPTOPP_NATIVE_DWORD_AVAILABLE</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>CRYPTOPP_COMPILE_ASSERT(<span class="keyword">sizeof</span>(dword) == 2*<span class="keyword">sizeof</span>(word));
<a name="l00029"></a>00029 <span class="preprocessor">#endif</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 <span class="keyword">const</span> std::string <a class="code" href="class_buffered_transformation.html#5e938c68f2a5e32a03440b1dc2bdc74a">BufferedTransformation::NULL_CHANNEL</a>;
<a name="l00032"></a><a class="code" href="cryptlib_8h.html#d3205973dd1afa14090a683154c1109c">00032</a> <span class="keyword">const</span> <a class="code" href="class_null_name_value_pairs.html" title="empty set of name-value pairs">NullNameValuePairs</a> g_nullNameValuePairs;
<a name="l00033"></a>00033 
<a name="l00034"></a><a class="code" href="cryptlib_8h.html#e42d0f5e86285a0fd540be52caabbfeb">00034</a> <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp; TheBitBucket()
<a name="l00035"></a>00035 {
<a name="l00036"></a>00036         <span class="keyword">static</span> <a class="code" href="class_bit_bucket.html">BitBucket</a> bitBucket;
<a name="l00037"></a>00037         <span class="keywordflow">return</span> bitBucket;
<a name="l00038"></a>00038 }
<a name="l00039"></a>00039 
<a name="l00040"></a><a class="code" href="class_algorithm.html#1c77f5117ca2cd881baf26a364cfc606">00040</a> <a class="code" href="class_algorithm.html#1c77f5117ca2cd881baf26a364cfc606">Algorithm::Algorithm</a>(<span class="keywordtype">bool</span> checkSelfTestStatus)
<a name="l00041"></a>00041 {
<a name="l00042"></a>00042         <span class="keywordflow">if</span> (checkSelfTestStatus &amp;&amp; FIPS_140_2_ComplianceEnabled())
<a name="l00043"></a>00043         {
<a name="l00044"></a>00044                 <span class="keywordflow">if</span> (GetPowerUpSelfTestStatus() == <a class="code" href="fips140_8h.html#8ccac50ac3bfc5abaa6cb457f0ded35d50805cb51444d59eb747962fa279ad27">POWER_UP_SELF_TEST_NOT_DONE</a> &amp;&amp; !PowerUpSelfTestInProgressOnThisThread())
<a name="l00045"></a>00045                         <span class="keywordflow">throw</span> <a class="code" href="class_self_test_failure.html" title="exception thrown when a crypto algorithm is used after a self test fails">SelfTestFailure</a>(<span class="stringliteral">"Cryptographic algorithms are disabled before the power-up self tests are performed."</span>);
<a name="l00046"></a>00046 
<a name="l00047"></a>00047                 <span class="keywordflow">if</span> (GetPowerUpSelfTestStatus() == <a class="code" href="fips140_8h.html#8ccac50ac3bfc5abaa6cb457f0ded35d7fdf030b911a428fda600038ef914c95">POWER_UP_SELF_TEST_FAILED</a>)
<a name="l00048"></a>00048                         <span class="keywordflow">throw</span> <a class="code" href="class_self_test_failure.html" title="exception thrown when a crypto algorithm is used after a self test fails">SelfTestFailure</a>(<span class="stringliteral">"Cryptographic algorithms are disabled after a power-up self test failed."</span>);
<a name="l00049"></a>00049         }
<a name="l00050"></a>00050 }
<a name="l00051"></a>00051 
<a name="l00052"></a><a class="code" href="class_simple_keying_interface.html#df3c29b3ef3af74788a58c7c49887fd7">00052</a> <span class="keywordtype">void</span> <a class="code" href="class_simple_keying_interface.html#df3c29b3ef3af74788a58c7c49887fd7" title="set or reset the key of this object">SimpleKeyingInterface::SetKey</a>(<span class="keyword">const</span> byte *key, <span class="keywordtype">size_t</span> length, <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;params)
<a name="l00053"></a>00053 {
<a name="l00054"></a>00054         this-&gt;<a class="code" href="class_simple_keying_interface.html#32b2095542b18025814118734bf34da2">ThrowIfInvalidKeyLength</a>(length);
<a name="l00055"></a>00055         this-&gt;UncheckedSetKey(key, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)length, params);
<a name="l00056"></a>00056 }
<a name="l00057"></a>00057 
<a name="l00058"></a><a class="code" href="class_simple_keying_interface.html#0401f9c67930805180964bc02ae0ac1c">00058</a> <span class="keywordtype">void</span> <a class="code" href="class_simple_keying_interface.html#0401f9c67930805180964bc02ae0ac1c" title="calls SetKey() with an NameValuePairs object that just specifies "Rounds"">SimpleKeyingInterface::SetKeyWithRounds</a>(<span class="keyword">const</span> byte *key, <span class="keywordtype">size_t</span> length, <span class="keywordtype">int</span> rounds)
<a name="l00059"></a>00059 {
<a name="l00060"></a>00060         <a class="code" href="class_simple_keying_interface.html#df3c29b3ef3af74788a58c7c49887fd7" title="set or reset the key of this object">SetKey</a>(key, length, MakeParameters(<a class="code" href="namespace_name.html#ef07deb188a711a240d95f3ccddc9e8e" title="int">Name::Rounds</a>(), rounds));
<a name="l00061"></a>00061 }
<a name="l00062"></a>00062 
<a name="l00063"></a><a class="code" href="class_simple_keying_interface.html#c25e27eaeae2e909741c07de93caef49">00063</a> <span class="keywordtype">void</span> <a class="code" href="class_simple_keying_interface.html#c25e27eaeae2e909741c07de93caef49" title="calls SetKey() with an NameValuePairs object that just specifies "IV"">SimpleKeyingInterface::SetKeyWithIV</a>(<span class="keyword">const</span> byte *key, <span class="keywordtype">size_t</span> length, <span class="keyword">const</span> byte *iv)
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065         <a class="code" href="class_simple_keying_interface.html#df3c29b3ef3af74788a58c7c49887fd7" title="set or reset the key of this object">SetKey</a>(key, length, MakeParameters(<a class="code" href="namespace_name.html#9b6839240a8bdf1f5bcbebf1866f4733" title="const byte *">Name::IV</a>(), iv));
<a name="l00066"></a>00066 }
<a name="l00067"></a>00067 
<a name="l00068"></a><a class="code" href="class_simple_keying_interface.html#32b2095542b18025814118734bf34da2">00068</a> <span class="keywordtype">void</span> <a class="code" href="class_simple_keying_interface.html#32b2095542b18025814118734bf34da2">SimpleKeyingInterface::ThrowIfInvalidKeyLength</a>(<span class="keywordtype">size_t</span> length)
<a name="l00069"></a>00069 {
<a name="l00070"></a>00070         <span class="keywordflow">if</span> (!<a class="code" href="class_simple_keying_interface.html#2229cdb9d7ac7e2cf3b02b39ae59ad77" title="returns whether n is a valid key length">IsValidKeyLength</a>(length))
<a name="l00071"></a>00071                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_key_length.html" title="_">InvalidKeyLength</a>(GetAlgorithm().AlgorithmName(), length);
<a name="l00072"></a>00072 }
<a name="l00073"></a>00073 
<a name="l00074"></a><a class="code" href="class_simple_keying_interface.html#e60d9774af66fc673fe6139f5880c477">00074</a> <span class="keywordtype">void</span> <a class="code" href="class_simple_keying_interface.html#e60d9774af66fc673fe6139f5880c477">SimpleKeyingInterface::ThrowIfResynchronizable</a>()
<a name="l00075"></a>00075 {
<a name="l00076"></a>00076         <span class="keywordflow">if</span> (<a class="code" href="class_simple_keying_interface.html#71039112353cc70e9859ebd95037cc1a" title="returns whether this object can be resynchronized (i.e. supports initialization vectors)...">IsResynchronizable</a>())
<a name="l00077"></a>00077                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(GetAlgorithm().AlgorithmName() + <span class="stringliteral">": this object requires an IV"</span>);
<a name="l00078"></a>00078 }
<a name="l00079"></a>00079 
<a name="l00080"></a><a class="code" href="class_simple_keying_interface.html#c687add7d0a09c626d85b77714bbd114">00080</a> <span class="keywordtype">void</span> <a class="code" href="class_simple_keying_interface.html#c687add7d0a09c626d85b77714bbd114">SimpleKeyingInterface::ThrowIfInvalidIV</a>(<span class="keyword">const</span> byte *iv)
<a name="l00081"></a>00081 {
<a name="l00082"></a>00082         <span class="keywordflow">if</span> (!iv &amp;&amp; !(<a class="code" href="class_simple_keying_interface.html#22087180aa396209403b0852e9efc431" title="returns the minimal requirement for secure IVs">IVRequirement</a>() == <a class="code" href="class_simple_keying_interface.html#88201c180fbfaa9fef2715252546ad6eb659bf6d2c470c50c14bfbab5b2d45ab">INTERNALLY_GENERATED_IV</a> || <a class="code" href="class_simple_keying_interface.html#22087180aa396209403b0852e9efc431" title="returns the minimal requirement for secure IVs">IVRequirement</a>() == <a class="code" href="class_simple_keying_interface.html#88201c180fbfaa9fef2715252546ad6e1cc32e69fe4f385e54d9d482a2ab5a56">UNIQUE_IV</a> || !<a class="code" href="class_simple_keying_interface.html#71039112353cc70e9859ebd95037cc1a" title="returns whether this object can be resynchronized (i.e. supports initialization vectors)...">IsResynchronizable</a>()))
<a name="l00083"></a>00083                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(GetAlgorithm().AlgorithmName() + <span class="stringliteral">": this object cannot use a null IV"</span>);
<a name="l00084"></a>00084 }
<a name="l00085"></a>00085 
<a name="l00086"></a><a class="code" href="class_simple_keying_interface.html#8d63825e000442603429b6f433b798f5">00086</a> <span class="keyword">const</span> byte * <a class="code" href="class_simple_keying_interface.html#8d63825e000442603429b6f433b798f5">SimpleKeyingInterface::GetIVAndThrowIfInvalid</a>(<span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;params)
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088         <span class="keyword">const</span> byte *iv;
<a name="l00089"></a>00089         <span class="keywordflow">if</span> (params.<a class="code" href="class_name_value_pairs.html#96686e9f8d6ce3ab870e516fb72b608e" title="get a named value, returns true if the name exists">GetValue</a>(<a class="code" href="namespace_name.html#9b6839240a8bdf1f5bcbebf1866f4733" title="const byte *">Name::IV</a>(), iv))
<a name="l00090"></a>00090                 <a class="code" href="class_simple_keying_interface.html#c687add7d0a09c626d85b77714bbd114">ThrowIfInvalidIV</a>(iv);
<a name="l00091"></a>00091         <span class="keywordflow">else</span>
<a name="l00092"></a>00092                 <a class="code" href="class_simple_keying_interface.html#e60d9774af66fc673fe6139f5880c477">ThrowIfResynchronizable</a>();
<a name="l00093"></a>00093         <span class="keywordflow">return</span> iv;
<a name="l00094"></a>00094 }
<a name="l00095"></a>00095 
<a name="l00096"></a><a class="code" href="class_simple_keying_interface.html#917224bb6df7431d6469e7a10feac5fa">00096</a> <span class="keywordtype">void</span> <a class="code" href="class_simple_keying_interface.html#917224bb6df7431d6469e7a10feac5fa" title="get a secure IV for the next message">SimpleKeyingInterface::GetNextIV</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, byte *IV)
<a name="l00097"></a>00097 {
<a name="l00098"></a>00098         rng.<a class="code" href="class_random_number_generator.html#497145546d24e6d4abaf10b7e0f1ba17" title="generate random array of bytes">GenerateBlock</a>(IV, <a class="code" href="class_simple_keying_interface.html#c6da9a8d3c783014ab54a2a3ee9e676a" title="returns size of IVs used by this object">IVSize</a>());
<a name="l00099"></a>00099 }
<a name="l00100"></a>00100 
<a name="l00101"></a><a class="code" href="class_block_transformation.html#9efa0ea24795a19d15c9aa0d7f134562">00101</a> <span class="keywordtype">void</span> <a class="code" href="class_block_transformation.html#9efa0ea24795a19d15c9aa0d7f134562" title="encrypt or decrypt multiple blocks, for bit-slicing implementations">BlockTransformation::ProcessAndXorMultipleBlocks</a>(<span class="keyword">const</span> byte *inBlocks, <span class="keyword">const</span> byte *xorBlocks, byte *outBlocks, <span class="keywordtype">size_t</span> numberOfBlocks)<span class="keyword"> const</span>
<a name="l00102"></a>00102 <span class="keyword"></span>{
<a name="l00103"></a>00103         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> blockSize = <a class="code" href="class_block_transformation.html#4936bef4368804cf5cadab9eb6eb37e4" title="block size of the cipher in bytes">BlockSize</a>();
<a name="l00104"></a>00104         <span class="keywordflow">while</span> (numberOfBlocks--)
<a name="l00105"></a>00105         {
<a name="l00106"></a>00106                 <a class="code" href="class_block_transformation.html#1904cf145e4c5c650dd7aff32f54e153" title="encrypt or decrypt inBlock, xor with xorBlock, and write to outBlock">ProcessAndXorBlock</a>(inBlocks, xorBlocks, outBlocks);
<a name="l00107"></a>00107                 inBlocks += blockSize;
<a name="l00108"></a>00108                 outBlocks += blockSize;
<a name="l00109"></a>00109                 <span class="keywordflow">if</span> (xorBlocks)
<a name="l00110"></a>00110                         xorBlocks += blockSize;
<a name="l00111"></a>00111         }
<a name="l00112"></a>00112 }
<a name="l00113"></a>00113 
<a name="l00114"></a><a class="code" href="class_block_transformation.html#f2da7e22f6b6ddda72bc7db2aceaa67a">00114</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_block_transformation.html#f2da7e22f6b6ddda72bc7db2aceaa67a" title="block pointers must be divisible by this">BlockTransformation::BlockAlignment</a>()<span class="keyword"> const</span>
<a name="l00115"></a>00115 <span class="keyword"></span>{
<a name="l00116"></a>00116         <span class="keywordflow">return</span> GetAlignmentOf&lt;word32&gt;();
<a name="l00117"></a>00117 }
<a name="l00118"></a>00118 
<a name="l00119"></a><a class="code" href="class_stream_transformation.html#0668b78edaea082f87bf3e878c4c02f7">00119</a> <span class="keywordtype">void</span> <a class="code" href="class_stream_transformation.html#0668b78edaea082f87bf3e878c4c02f7" title="for ciphers where the last block of data is special, encrypt or decrypt the last...">StreamTransformation::ProcessLastBlock</a>(byte *outString, <span class="keyword">const</span> byte *inString, <span class="keywordtype">size_t</span> length)
<a name="l00120"></a>00120 {
<a name="l00121"></a>00121         assert(<a class="code" href="class_stream_transformation.html#0b7c5bc41b9b5f6443ee32d65ebc044c" title="returns the minimum size of the last block, 0 indicating the last block is not special...">MinLastBlockSize</a>() == 0);        <span class="comment">// this function should be overriden otherwise</span>
<a name="l00122"></a>00122 
<a name="l00123"></a>00123         <span class="keywordflow">if</span> (length == <a class="code" href="class_stream_transformation.html#e224d250f716e82c54bc4e4c8930d188" title="returns block size, if input must be processed in blocks, otherwise 1">MandatoryBlockSize</a>())
<a name="l00124"></a>00124                 <a class="code" href="class_stream_transformation.html#26feabde21bc4d1783195969733e3bb0" title="encrypt or decrypt an array of bytes of specified length">ProcessData</a>(outString, inString, length);
<a name="l00125"></a>00125         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (length != 0)
<a name="l00126"></a>00126                 <span class="keywordflow">throw</span> <a class="code" href="class_not_implemented.html" title="exception thrown by a class if a non-implemented method is called">NotImplemented</a>(<span class="stringliteral">"StreamTransformation: this object does't support a special last block"</span>);
<a name="l00127"></a>00127 }
<a name="l00128"></a>00128 
<a name="l00129"></a><a class="code" href="class_random_number_generator.html#ce592244cfbd6c18398ea6c75857532e">00129</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_random_number_generator.html#ce592244cfbd6c18398ea6c75857532e" title="generate new random bit and return it">RandomNumberGenerator::GenerateBit</a>()
<a name="l00130"></a>00130 {
<a name="l00131"></a>00131         <span class="keywordflow">return</span> <a class="code" href="class_random_number_generator.html#da0f7c437b0c8e6ba94ebcd75bff4bda" title="generate new random byte and return it">GenerateByte</a>() &amp; 1;
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00134"></a><a class="code" href="class_random_number_generator.html#da0f7c437b0c8e6ba94ebcd75bff4bda">00134</a> byte <a class="code" href="class_random_number_generator.html#da0f7c437b0c8e6ba94ebcd75bff4bda" title="generate new random byte and return it">RandomNumberGenerator::GenerateByte</a>()
<a name="l00135"></a>00135 {
<a name="l00136"></a>00136         byte b;
<a name="l00137"></a>00137         <a class="code" href="class_random_number_generator.html#497145546d24e6d4abaf10b7e0f1ba17" title="generate random array of bytes">GenerateBlock</a>(&amp;b, 1);
<a name="l00138"></a>00138         <span class="keywordflow">return</span> b;
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 
<a name="l00141"></a><a class="code" href="class_random_number_generator.html#c06c9f5e66f35d643e4192f231b8a4cd">00141</a> word32 <a class="code" href="class_random_number_generator.html#c06c9f5e66f35d643e4192f231b8a4cd" title="generate a random 32 bit word in the range min to max, inclusive">RandomNumberGenerator::GenerateWord32</a>(word32 min, word32 max)
<a name="l00142"></a>00142 {
<a name="l00143"></a>00143         word32 range = max-min;
<a name="l00144"></a>00144         <span class="keyword">const</span> <span class="keywordtype">int</span> maxBits = BitPrecision(range);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146         word32 value;
<a name="l00147"></a>00147 
<a name="l00148"></a>00148         <span class="keywordflow">do</span>
<a name="l00149"></a>00149         {
<a name="l00150"></a>00150                 <a class="code" href="class_random_number_generator.html#497145546d24e6d4abaf10b7e0f1ba17" title="generate random array of bytes">GenerateBlock</a>((byte *)&amp;value, <span class="keyword">sizeof</span>(value));
<a name="l00151"></a>00151                 value = Crop(value, maxBits);
<a name="l00152"></a>00152         } <span class="keywordflow">while</span> (value &gt; range);
<a name="l00153"></a>00153 
<a name="l00154"></a>00154         <span class="keywordflow">return</span> value+min;
<a name="l00155"></a>00155 }
<a name="l00156"></a>00156 
<a name="l00157"></a><a class="code" href="class_random_number_generator.html#497145546d24e6d4abaf10b7e0f1ba17">00157</a> <span class="keywordtype">void</span> <a class="code" href="class_random_number_generator.html#497145546d24e6d4abaf10b7e0f1ba17" title="generate random array of bytes">RandomNumberGenerator::GenerateBlock</a>(byte *output, <span class="keywordtype">size_t</span> size)
<a name="l00158"></a>00158 {
<a name="l00159"></a>00159         <a class="code" href="class_array_sink.html" title="Copy input to a memory buffer.">ArraySink</a> s(output, size);
<a name="l00160"></a>00160         <a class="code" href="class_random_number_generator.html#5cc474006e2c7383ec20cc4d0c2abbaf" title="generate random bytes as input to a BufferedTransformation">GenerateIntoBufferedTransformation</a>(s, BufferedTransformation::NULL_CHANNEL, size);
<a name="l00161"></a>00161 }
<a name="l00162"></a>00162 
<a name="l00163"></a><a class="code" href="class_random_number_generator.html#44f70ad8fed869a4ee55f50ef8e6e699">00163</a> <span class="keywordtype">void</span> <a class="code" href="class_random_number_generator.html#44f70ad8fed869a4ee55f50ef8e6e699" title="generate and discard n bytes">RandomNumberGenerator::DiscardBytes</a>(<span class="keywordtype">size_t</span> n)
<a name="l00164"></a>00164 {
<a name="l00165"></a>00165         <a class="code" href="class_random_number_generator.html#5cc474006e2c7383ec20cc4d0c2abbaf" title="generate random bytes as input to a BufferedTransformation">GenerateIntoBufferedTransformation</a>(TheBitBucket(), BufferedTransformation::NULL_CHANNEL, n);
<a name="l00166"></a>00166 }
<a name="l00167"></a>00167 
<a name="l00168"></a><a class="code" href="class_random_number_generator.html#5cc474006e2c7383ec20cc4d0c2abbaf">00168</a> <span class="keywordtype">void</span> <a class="code" href="class_random_number_generator.html#5cc474006e2c7383ec20cc4d0c2abbaf" title="generate random bytes as input to a BufferedTransformation">RandomNumberGenerator::GenerateIntoBufferedTransformation</a>(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;target, <span class="keyword">const</span> std::string &amp;channel, lword length)
<a name="l00169"></a>00169 {
<a name="l00170"></a>00170         <a class="code" href="class_fixed_size_sec_block.html" title="a SecBlock with fixed size, allocated statically">FixedSizeSecBlock&lt;byte, 256&gt;</a> buffer;
<a name="l00171"></a>00171         <span class="keywordflow">while</span> (length)
<a name="l00172"></a>00172         {
<a name="l00173"></a>00173                 <span class="keywordtype">size_t</span> len = UnsignedMin(buffer.<a class="code" href="class_sec_block.html#f5999bffe3193e62719cc0792b0282a7">size</a>(), length);
<a name="l00174"></a>00174                 <a class="code" href="class_random_number_generator.html#497145546d24e6d4abaf10b7e0f1ba17" title="generate random array of bytes">GenerateBlock</a>(buffer, len);
<a name="l00175"></a>00175                 target.<a class="code" href="class_buffered_transformation.html#97a60b54fafdb3df59e1457ef629fc5f">ChannelPut</a>(channel, buffer, len);
<a name="l00176"></a>00176                 length -= len;
<a name="l00177"></a>00177         }
<a name="l00178"></a>00178 }
<a name="l00179"></a>00179 <span class="comment"></span>
<a name="l00180"></a>00180 <span class="comment">//! see NullRNG()</span>
<a name="l00181"></a><a class="code" href="class_class_null_r_n_g.html">00181</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_class_null_r_n_g.html" title="see NullRNG()">ClassNullRNG</a> : <span class="keyword">public</span> <a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a>
<a name="l00182"></a>00182 {
<a name="l00183"></a>00183 <span class="keyword">public</span>:
<a name="l00184"></a><a class="code" href="class_class_null_r_n_g.html#4339d2936dbca593ca7845de90a7420a">00184</a>         std::string <a class="code" href="class_algorithm.html#4f31510a192d1121856efe8ad0a9b844" title="returns name of this algorithm, not universally implemented yet">AlgorithmName</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <span class="stringliteral">"NullRNG"</span>;}
<a name="l00185"></a><a class="code" href="class_class_null_r_n_g.html#3fe959f398f36e108f2ba3e57f17644f">00185</a>         <span class="keywordtype">void</span> <a class="code" href="class_random_number_generator.html#497145546d24e6d4abaf10b7e0f1ba17" title="generate random array of bytes">GenerateBlock</a>(byte *output, <span class="keywordtype">size_t</span> size) {<span class="keywordflow">throw</span> <a class="code" href="class_not_implemented.html" title="exception thrown by a class if a non-implemented method is called">NotImplemented</a>(<span class="stringliteral">"NullRNG: NullRNG should only be passed to functions that don't need to generate random bytes"</span>);}
<a name="l00186"></a>00186 };
<a name="l00187"></a>00187 
<a name="l00188"></a><a class="code" href="cryptlib_8h.html#fcd6162a0a4d19df92106149e7eaf55a">00188</a> <a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp; NullRNG()
<a name="l00189"></a>00189 {
<a name="l00190"></a>00190         <span class="keyword">static</span> <a class="code" href="class_class_null_r_n_g.html" title="see NullRNG()">ClassNullRNG</a> s_nullRNG;
<a name="l00191"></a>00191         <span class="keywordflow">return</span> s_nullRNG;
<a name="l00192"></a>00192 }
<a name="l00193"></a>00193 
<a name="l00194"></a><a class="code" href="class_hash_transformation.html#0f6069eadf492d970c3eb8cdf656e742">00194</a> <span class="keywordtype">bool</span> <a class="code" href="class_hash_transformation.html#0f6069eadf492d970c3eb8cdf656e742" title="truncated version of Verify()">HashTransformation::TruncatedVerify</a>(<span class="keyword">const</span> byte *digestIn, <span class="keywordtype">size_t</span> digestLength)
<a name="l00195"></a>00195 {
<a name="l00196"></a>00196         <a class="code" href="class_hash_transformation.html#64ba03d31c489dc32b50e00d377d8032">ThrowIfInvalidTruncatedSize</a>(digestLength);
<a name="l00197"></a>00197         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> digest(digestLength);
<a name="l00198"></a>00198         <a class="code" href="class_hash_transformation.html#590ecda344aa0fb045abf42ec08823b2" title="truncated version of Final()">TruncatedFinal</a>(digest, digestLength);
<a name="l00199"></a>00199         <span class="keywordflow">return</span> memcmp(digest, digestIn, digestLength) == 0;
<a name="l00200"></a>00200 }
<a name="l00201"></a>00201 
<a name="l00202"></a><a class="code" href="class_hash_transformation.html#64ba03d31c489dc32b50e00d377d8032">00202</a> <span class="keywordtype">void</span> <a class="code" href="class_hash_transformation.html#64ba03d31c489dc32b50e00d377d8032">HashTransformation::ThrowIfInvalidTruncatedSize</a>(<span class="keywordtype">size_t</span> size)<span class="keyword"> const</span>
<a name="l00203"></a>00203 <span class="keyword"></span>{
<a name="l00204"></a>00204         <span class="keywordflow">if</span> (size &gt; <a class="code" href="class_hash_transformation.html#41faf8b1293a6c72390cb0c8bd668097" title="size of the hash returned by Final()">DigestSize</a>())
<a name="l00205"></a>00205                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(<span class="stringliteral">"HashTransformation: can't truncate a "</span> + IntToString(<a class="code" href="class_hash_transformation.html#41faf8b1293a6c72390cb0c8bd668097" title="size of the hash returned by Final()">DigestSize</a>()) + <span class="stringliteral">" byte digest to "</span> + IntToString(size) + <span class="stringliteral">" bytes"</span>);
<a name="l00206"></a>00206 }
<a name="l00207"></a>00207 
<a name="l00208"></a><a class="code" href="class_buffered_transformation.html#051a0b5e3e4cc81aca43a9c6cb02e0f9">00208</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_buffered_transformation.html#051a0b5e3e4cc81aca43a9c6cb02e0f9" title="maximum number of wait objects that this object can return">BufferedTransformation::GetMaxWaitObjectCount</a>()<span class="keyword"> const</span>
<a name="l00209"></a>00209 <span class="keyword"></span>{
<a name="l00210"></a>00210         <span class="keyword">const</span> <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *t = <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>();
<a name="l00211"></a>00211         <span class="keywordflow">return</span> t ? t-&gt;<a class="code" href="class_buffered_transformation.html#051a0b5e3e4cc81aca43a9c6cb02e0f9" title="maximum number of wait objects that this object can return">GetMaxWaitObjectCount</a>() : 0;
<a name="l00212"></a>00212 }
<a name="l00213"></a>00213 
<a name="l00214"></a><a class="code" href="class_buffered_transformation.html#127ccd1793fdda6548cd1295f848d0f7">00214</a> <span class="keywordtype">void</span> <a class="code" href="class_buffered_transformation.html#127ccd1793fdda6548cd1295f848d0f7" title="put wait objects into container">BufferedTransformation::GetWaitObjects</a>(<a class="code" href="class_wait_object_container.html" title="container of wait objects">WaitObjectContainer</a> &amp;container, <a class="code" href="class_call_stack.html">CallStack</a> <span class="keyword">const</span>&amp; callStack)
<a name="l00215"></a>00215 {
<a name="l00216"></a>00216         <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *t = <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>();
<a name="l00217"></a>00217         <span class="keywordflow">if</span> (t)
<a name="l00218"></a>00218                 t-&gt;<a class="code" href="class_buffered_transformation.html#127ccd1793fdda6548cd1295f848d0f7" title="put wait objects into container">GetWaitObjects</a>(container, callStack);  <span class="comment">// reduce clutter by not adding to stack here</span>
<a name="l00219"></a>00219 }
<a name="l00220"></a>00220 
<a name="l00221"></a><a class="code" href="class_buffered_transformation.html#0dd5456c06e0e47d901e8055b50df929">00221</a> <span class="keywordtype">void</span> <a class="code" href="class_buffered_transformation.html#0dd5456c06e0e47d901e8055b50df929" title="initialize or reinitialize this object">BufferedTransformation::Initialize</a>(<span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;parameters, <span class="keywordtype">int</span> propagation)
<a name="l00222"></a>00222 {
<a name="l00223"></a>00223         assert(!<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>());
<a name="l00224"></a>00224         <a class="code" href="class_buffered_transformation.html#7bb05ac3b6302e2ab994586d526fa804">IsolatedInitialize</a>(parameters);
<a name="l00225"></a>00225 }
<a name="l00226"></a>00226 
<a name="l00227"></a><a class="code" href="class_buffered_transformation.html#8a62b1b6c8f310363f32b05b20c306eb">00227</a> <span class="keywordtype">bool</span> <a class="code" href="class_buffered_transformation.html#8a62b1b6c8f310363f32b05b20c306eb" title="flush buffered input and/or output">BufferedTransformation::Flush</a>(<span class="keywordtype">bool</span> hardFlush, <span class="keywordtype">int</span> propagation, <span class="keywordtype">bool</span> blocking)
<a name="l00228"></a>00228 {
<a name="l00229"></a>00229         assert(!<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>());
<a name="l00230"></a>00230         <span class="keywordflow">return</span> IsolatedFlush(hardFlush, blocking);
<a name="l00231"></a>00231 }
<a name="l00232"></a>00232 
<a name="l00233"></a><a class="code" href="class_buffered_transformation.html#ae4c5ae024419e31bfa0c24eb35b24c2">00233</a> <span class="keywordtype">bool</span> <a class="code" href="class_buffered_transformation.html#ae4c5ae024419e31bfa0c24eb35b24c2" title="mark end of a series of messages">BufferedTransformation::MessageSeriesEnd</a>(<span class="keywordtype">int</span> propagation, <span class="keywordtype">bool</span> blocking)
<a name="l00234"></a>00234 {
<a name="l00235"></a>00235         assert(!<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>());
<a name="l00236"></a>00236         <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#af09f0cd6dbd022539a9ac5c316d4984">IsolatedMessageSeriesEnd</a>(blocking);
<a name="l00237"></a>00237 }
<a name="l00238"></a>00238 
<a name="l00239"></a><a class="code" href="class_buffered_transformation.html#877494d8de597af935cb770034f7f170">00239</a> byte * <a class="code" href="class_buffered_transformation.html#877494d8de597af935cb770034f7f170">BufferedTransformation::ChannelCreatePutSpace</a>(<span class="keyword">const</span> std::string &amp;channel, <span class="keywordtype">size_t</span> &amp;size)
<a name="l00240"></a>00240 {
<a name="l00241"></a>00241         <span class="keywordflow">if</span> (channel.empty())
<a name="l00242"></a>00242                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#f390325c959c3d6a2c03a447d6cd469d" title="request space which can be written into by the caller, and then used as input to...">CreatePutSpace</a>(size);
<a name="l00243"></a>00243         <span class="keywordflow">else</span>
<a name="l00244"></a>00244                 <span class="keywordflow">throw</span> <a class="code" href="struct_buffered_transformation_1_1_no_channel_support.html">NoChannelSupport</a>();
<a name="l00245"></a>00245 }
<a name="l00246"></a>00246 
<a name="l00247"></a><a class="code" href="class_buffered_transformation.html#825c38044d268f6d561cb7f849e04b13">00247</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#825c38044d268f6d561cb7f849e04b13">BufferedTransformation::ChannelPut2</a>(<span class="keyword">const</span> std::string &amp;channel, <span class="keyword">const</span> byte *begin, <span class="keywordtype">size_t</span> length, <span class="keywordtype">int</span> messageEnd, <span class="keywordtype">bool</span> blocking)
<a name="l00248"></a>00248 {
<a name="l00249"></a>00249         <span class="keywordflow">if</span> (channel.empty())
<a name="l00250"></a>00250                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#d396dcb42260f23125a35ec0e5d17d55" title="input multiple bytes for blocking or non-blocking processing">Put2</a>(begin, length, messageEnd, blocking);
<a name="l00251"></a>00251         <span class="keywordflow">else</span>
<a name="l00252"></a>00252                 <span class="keywordflow">throw</span> <a class="code" href="struct_buffered_transformation_1_1_no_channel_support.html">NoChannelSupport</a>();
<a name="l00253"></a>00253 }
<a name="l00254"></a>00254 
<a name="l00255"></a><a class="code" href="class_buffered_transformation.html#eab62459524d9c93531ec365ba930be3">00255</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#eab62459524d9c93531ec365ba930be3">BufferedTransformation::ChannelPutModifiable2</a>(<span class="keyword">const</span> std::string &amp;channel, byte *begin, <span class="keywordtype">size_t</span> length, <span class="keywordtype">int</span> messageEnd, <span class="keywordtype">bool</span> blocking)
<a name="l00256"></a>00256 {
<a name="l00257"></a>00257         <span class="keywordflow">if</span> (channel.empty())
<a name="l00258"></a>00258                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#770bf11f26d4dec66423a7dc2d36843d" title="input multiple bytes that may be modified by callee for blocking or non-blocking...">PutModifiable2</a>(begin, length, messageEnd, blocking);
<a name="l00259"></a>00259         <span class="keywordflow">else</span>
<a name="l00260"></a>00260                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#825c38044d268f6d561cb7f849e04b13">ChannelPut2</a>(channel, begin, length, messageEnd, blocking);
<a name="l00261"></a>00261 }
<a name="l00262"></a>00262 
<a name="l00263"></a><a class="code" href="class_buffered_transformation.html#6b504b2694ecb5d709a9858c5b93a0f7">00263</a> <span class="keywordtype">bool</span> <a class="code" href="class_buffered_transformation.html#6b504b2694ecb5d709a9858c5b93a0f7">BufferedTransformation::ChannelFlush</a>(<span class="keyword">const</span> std::string &amp;channel, <span class="keywordtype">bool</span> completeFlush, <span class="keywordtype">int</span> propagation, <span class="keywordtype">bool</span> blocking)
<a name="l00264"></a>00264 {
<a name="l00265"></a>00265         <span class="keywordflow">if</span> (channel.empty())
<a name="l00266"></a>00266                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#8a62b1b6c8f310363f32b05b20c306eb" title="flush buffered input and/or output">Flush</a>(completeFlush, propagation, blocking);
<a name="l00267"></a>00267         <span class="keywordflow">else</span>
<a name="l00268"></a>00268                 <span class="keywordflow">throw</span> <a class="code" href="struct_buffered_transformation_1_1_no_channel_support.html">NoChannelSupport</a>();
<a name="l00269"></a>00269 }
<a name="l00270"></a>00270 
<a name="l00271"></a><a class="code" href="class_buffered_transformation.html#e0fc63d42d94958f71fc573b17469921">00271</a> <span class="keywordtype">bool</span> <a class="code" href="class_buffered_transformation.html#e0fc63d42d94958f71fc573b17469921">BufferedTransformation::ChannelMessageSeriesEnd</a>(<span class="keyword">const</span> std::string &amp;channel, <span class="keywordtype">int</span> propagation, <span class="keywordtype">bool</span> blocking)
<a name="l00272"></a>00272 {
<a name="l00273"></a>00273         <span class="keywordflow">if</span> (channel.empty())
<a name="l00274"></a>00274                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ae4c5ae024419e31bfa0c24eb35b24c2" title="mark end of a series of messages">MessageSeriesEnd</a>(propagation, blocking);
<a name="l00275"></a>00275         <span class="keywordflow">else</span>
<a name="l00276"></a>00276                 <span class="keywordflow">throw</span> <a class="code" href="struct_buffered_transformation_1_1_no_channel_support.html">NoChannelSupport</a>();
<a name="l00277"></a>00277 }
<a name="l00278"></a>00278 
<a name="l00279"></a><a class="code" href="class_buffered_transformation.html#30b2076bce5fb29e992b6457485c67c2">00279</a> lword <a class="code" href="class_buffered_transformation.html#30b2076bce5fb29e992b6457485c67c2" title="returns number of bytes that is currently ready for retrieval">BufferedTransformation::MaxRetrievable</a>()<span class="keyword"> const</span>
<a name="l00280"></a>00280 <span class="keyword"></span>{
<a name="l00281"></a>00281         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00282"></a>00282                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#30b2076bce5fb29e992b6457485c67c2" title="returns number of bytes that is currently ready for retrieval">MaxRetrievable</a>();
<a name="l00283"></a>00283         <span class="keywordflow">else</span>
<a name="l00284"></a>00284                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#8d4359262c67b3e10d193ba30ef193c5" title="copy copyMax bytes of the buffered output to target as input">CopyTo</a>(TheBitBucket());
<a name="l00285"></a>00285 }
<a name="l00286"></a>00286 
<a name="l00287"></a><a class="code" href="class_buffered_transformation.html#8c1e2ca57fc06a1f3694d8fe7f8508ff">00287</a> <span class="keywordtype">bool</span> <a class="code" href="class_buffered_transformation.html#8c1e2ca57fc06a1f3694d8fe7f8508ff" title="returns whether any bytes are currently ready for retrieval">BufferedTransformation::AnyRetrievable</a>()<span class="keyword"> const</span>
<a name="l00288"></a>00288 <span class="keyword"></span>{
<a name="l00289"></a>00289         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00290"></a>00290                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#8c1e2ca57fc06a1f3694d8fe7f8508ff" title="returns whether any bytes are currently ready for retrieval">AnyRetrievable</a>();
<a name="l00291"></a>00291         <span class="keywordflow">else</span>
<a name="l00292"></a>00292         {
<a name="l00293"></a>00293                 byte b;
<a name="l00294"></a>00294                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">Peek</a>(b) != 0;
<a name="l00295"></a>00295         }
<a name="l00296"></a>00296 }
<a name="l00297"></a>00297 
<a name="l00298"></a><a class="code" href="class_buffered_transformation.html#9e1ad913c8fe697d269f408a7d5928fc">00298</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#9e1ad913c8fe697d269f408a7d5928fc" title="try to retrieve a single byte">BufferedTransformation::Get</a>(byte &amp;outByte)
<a name="l00299"></a>00299 {
<a name="l00300"></a>00300         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00301"></a>00301                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#9e1ad913c8fe697d269f408a7d5928fc" title="try to retrieve a single byte">Get</a>(outByte);
<a name="l00302"></a>00302         <span class="keywordflow">else</span>
<a name="l00303"></a>00303                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#9e1ad913c8fe697d269f408a7d5928fc" title="try to retrieve a single byte">Get</a>(&amp;outByte, 1);
<a name="l00304"></a>00304 }
<a name="l00305"></a>00305 
<a name="l00306"></a><a class="code" href="class_buffered_transformation.html#0a6f18a871720453e1791c64f0461a9f">00306</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#9e1ad913c8fe697d269f408a7d5928fc" title="try to retrieve a single byte">BufferedTransformation::Get</a>(byte *outString, <span class="keywordtype">size_t</span> getMax)
<a name="l00307"></a>00307 {
<a name="l00308"></a>00308         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00309"></a>00309                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#9e1ad913c8fe697d269f408a7d5928fc" title="try to retrieve a single byte">Get</a>(outString, getMax);
<a name="l00310"></a>00310         <span class="keywordflow">else</span>
<a name="l00311"></a>00311         {
<a name="l00312"></a>00312                 <a class="code" href="class_array_sink.html" title="Copy input to a memory buffer.">ArraySink</a> arraySink(outString, getMax);
<a name="l00313"></a>00313                 <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)<a class="code" href="class_buffered_transformation.html#91c4526148274ae9cb68803bb2d2a2aa" title="move transferMax bytes of the buffered output to target as input">TransferTo</a>(arraySink, getMax);
<a name="l00314"></a>00314         }
<a name="l00315"></a>00315 }
<a name="l00316"></a>00316 
<a name="l00317"></a><a class="code" href="class_buffered_transformation.html#5fa048faf8c043ad57ae0a8911070090">00317</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">BufferedTransformation::Peek</a>(byte &amp;outByte)<span class="keyword"> const</span>
<a name="l00318"></a>00318 <span class="keyword"></span>{
<a name="l00319"></a>00319         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00320"></a>00320                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">Peek</a>(outByte);
<a name="l00321"></a>00321         <span class="keywordflow">else</span>
<a name="l00322"></a>00322                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">Peek</a>(&amp;outByte, 1);
<a name="l00323"></a>00323 }
<a name="l00324"></a>00324 
<a name="l00325"></a><a class="code" href="class_buffered_transformation.html#acdeedab8dc8557d17b12b67a9ff94dc">00325</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">BufferedTransformation::Peek</a>(byte *outString, <span class="keywordtype">size_t</span> peekMax)<span class="keyword"> const</span>
<a name="l00326"></a>00326 <span class="keyword"></span>{
<a name="l00327"></a>00327         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00328"></a>00328                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">Peek</a>(outString, peekMax);
<a name="l00329"></a>00329         <span class="keywordflow">else</span>
<a name="l00330"></a>00330         {
<a name="l00331"></a>00331                 <a class="code" href="class_array_sink.html" title="Copy input to a memory buffer.">ArraySink</a> arraySink(outString, peekMax);
<a name="l00332"></a>00332                 <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)<a class="code" href="class_buffered_transformation.html#8d4359262c67b3e10d193ba30ef193c5" title="copy copyMax bytes of the buffered output to target as input">CopyTo</a>(arraySink, peekMax);
<a name="l00333"></a>00333         }
<a name="l00334"></a>00334 }
<a name="l00335"></a>00335 
<a name="l00336"></a><a class="code" href="class_buffered_transformation.html#0c25529ded99db20ad35ccef3f7234e6">00336</a> lword <a class="code" href="class_buffered_transformation.html#0c25529ded99db20ad35ccef3f7234e6" title="discard skipMax bytes from the output buffer">BufferedTransformation::Skip</a>(lword skipMax)
<a name="l00337"></a>00337 {
<a name="l00338"></a>00338         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00339"></a>00339                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#0c25529ded99db20ad35ccef3f7234e6" title="discard skipMax bytes from the output buffer">Skip</a>(skipMax);
<a name="l00340"></a>00340         <span class="keywordflow">else</span>
<a name="l00341"></a>00341                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#91c4526148274ae9cb68803bb2d2a2aa" title="move transferMax bytes of the buffered output to target as input">TransferTo</a>(TheBitBucket(), skipMax);
<a name="l00342"></a>00342 }
<a name="l00343"></a>00343 
<a name="l00344"></a><a class="code" href="class_buffered_transformation.html#b4e77f500d62436a8bd1597e6b6443a1">00344</a> lword <a class="code" href="class_buffered_transformation.html#b4e77f500d62436a8bd1597e6b6443a1">BufferedTransformation::TotalBytesRetrievable</a>()<span class="keyword"> const</span>
<a name="l00345"></a>00345 <span class="keyword"></span>{
<a name="l00346"></a>00346         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00347"></a>00347                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#b4e77f500d62436a8bd1597e6b6443a1">TotalBytesRetrievable</a>();
<a name="l00348"></a>00348         <span class="keywordflow">else</span>
<a name="l00349"></a>00349                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#30b2076bce5fb29e992b6457485c67c2" title="returns number of bytes that is currently ready for retrieval">MaxRetrievable</a>();
<a name="l00350"></a>00350 }
<a name="l00351"></a>00351 
<a name="l00352"></a><a class="code" href="class_buffered_transformation.html#56bcbb4306a9c04cda838f96e85a2116">00352</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_buffered_transformation.html#56bcbb4306a9c04cda838f96e85a2116" title="number of times MessageEnd() has been received minus messages retrieved or skipped...">BufferedTransformation::NumberOfMessages</a>()<span class="keyword"> const</span>
<a name="l00353"></a>00353 <span class="keyword"></span>{
<a name="l00354"></a>00354         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00355"></a>00355                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#56bcbb4306a9c04cda838f96e85a2116" title="number of times MessageEnd() has been received minus messages retrieved or skipped...">NumberOfMessages</a>();
<a name="l00356"></a>00356         <span class="keywordflow">else</span>
<a name="l00357"></a>00357                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#83945ad467ad20665cfb0a9a9a46ebec">CopyMessagesTo</a>(TheBitBucket());
<a name="l00358"></a>00358 }
<a name="l00359"></a>00359 
<a name="l00360"></a><a class="code" href="class_buffered_transformation.html#a0d7fdaa525a59cf72cdc431570f3df8">00360</a> <span class="keywordtype">bool</span> <a class="code" href="class_buffered_transformation.html#a0d7fdaa525a59cf72cdc431570f3df8" title="returns true if NumberOfMessages() &gt; 0">BufferedTransformation::AnyMessages</a>()<span class="keyword"> const</span>
<a name="l00361"></a>00361 <span class="keyword"></span>{
<a name="l00362"></a>00362         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00363"></a>00363                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a0d7fdaa525a59cf72cdc431570f3df8" title="returns true if NumberOfMessages() &gt; 0">AnyMessages</a>();
<a name="l00364"></a>00364         <span class="keywordflow">else</span>
<a name="l00365"></a>00365                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#56bcbb4306a9c04cda838f96e85a2116" title="number of times MessageEnd() has been received minus messages retrieved or skipped...">NumberOfMessages</a>() != 0;
<a name="l00366"></a>00366 }
<a name="l00367"></a>00367 
<a name="l00368"></a><a class="code" href="class_buffered_transformation.html#8dc8562950fd563f7c62d1f1e5ec6b1e">00368</a> <span class="keywordtype">bool</span> <a class="code" href="class_buffered_transformation.html#8dc8562950fd563f7c62d1f1e5ec6b1e" title="start retrieving the next message">BufferedTransformation::GetNextMessage</a>()
<a name="l00369"></a>00369 {
<a name="l00370"></a>00370         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00371"></a>00371                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#8dc8562950fd563f7c62d1f1e5ec6b1e" title="start retrieving the next message">GetNextMessage</a>();
<a name="l00372"></a>00372         <span class="keywordflow">else</span>
<a name="l00373"></a>00373         {
<a name="l00374"></a>00374                 assert(!<a class="code" href="class_buffered_transformation.html#a0d7fdaa525a59cf72cdc431570f3df8" title="returns true if NumberOfMessages() &gt; 0">AnyMessages</a>());
<a name="l00375"></a>00375                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00376"></a>00376         }
<a name="l00377"></a>00377 }
<a name="l00378"></a>00378 
<a name="l00379"></a><a class="code" href="class_buffered_transformation.html#ce560f14489f478bb4cd17c41905774e">00379</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_buffered_transformation.html#ce560f14489f478bb4cd17c41905774e" title="skip count number of messages">BufferedTransformation::SkipMessages</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count)
<a name="l00380"></a>00380 {
<a name="l00381"></a>00381         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00382"></a>00382                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#ce560f14489f478bb4cd17c41905774e" title="skip count number of messages">SkipMessages</a>(count);
<a name="l00383"></a>00383         <span class="keywordflow">else</span>
<a name="l00384"></a>00384                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#c80a018cfc3eb7c4ae3f0d4a804eb6d5">TransferMessagesTo</a>(TheBitBucket(), count);
<a name="l00385"></a>00385 }
<a name="l00386"></a>00386 
<a name="l00387"></a><a class="code" href="class_buffered_transformation.html#0a9ba0f5307ff55f7e1a828188728985">00387</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#0a9ba0f5307ff55f7e1a828188728985" title="upon return, messageCount contains number of messages that have finished being transfered...">BufferedTransformation::TransferMessagesTo2</a>(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;target, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;messageCount, <span class="keyword">const</span> std::string &amp;channel, <span class="keywordtype">bool</span> blocking)
<a name="l00388"></a>00388 {
<a name="l00389"></a>00389         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00390"></a>00390                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#0a9ba0f5307ff55f7e1a828188728985" title="upon return, messageCount contains number of messages that have finished being transfered...">TransferMessagesTo2</a>(target, messageCount, channel, blocking);
<a name="l00391"></a>00391         <span class="keywordflow">else</span>
<a name="l00392"></a>00392         {
<a name="l00393"></a>00393                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxMessages = messageCount;
<a name="l00394"></a>00394                 <span class="keywordflow">for</span> (messageCount=0; messageCount &lt; maxMessages &amp;&amp; <a class="code" href="class_buffered_transformation.html#a0d7fdaa525a59cf72cdc431570f3df8" title="returns true if NumberOfMessages() &gt; 0">AnyMessages</a>(); messageCount++)
<a name="l00395"></a>00395                 {
<a name="l00396"></a>00396                         <span class="keywordtype">size_t</span> blockedBytes;
<a name="l00397"></a>00397                         lword transferredBytes;
<a name="l00398"></a>00398 
<a name="l00399"></a>00399                         <span class="keywordflow">while</span> (<a class="code" href="class_buffered_transformation.html#8c1e2ca57fc06a1f3694d8fe7f8508ff" title="returns whether any bytes are currently ready for retrieval">AnyRetrievable</a>())
<a name="l00400"></a>00400                         {
<a name="l00401"></a>00401                                 transferredBytes = LWORD_MAX;
<a name="l00402"></a>00402                                 blockedBytes = <a class="code" href="class_buffered_transformation.html#041e8af260c474a43bd232cd4143f406" title="upon return, byteCount contains number of bytes that have finished being transfered...">TransferTo2</a>(target, transferredBytes, channel, blocking);
<a name="l00403"></a>00403                                 <span class="keywordflow">if</span> (blockedBytes &gt; 0)
<a name="l00404"></a>00404                                         <span class="keywordflow">return</span> blockedBytes;
<a name="l00405"></a>00405                         }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407                         <span class="keywordflow">if</span> (target.<a class="code" href="class_buffered_transformation.html#e0b37b299c5835083e58b205f9cc25cc">ChannelMessageEnd</a>(channel, <a class="code" href="class_buffered_transformation.html#76a32fc46e74c3c509934a11b8f5fec7">GetAutoSignalPropagation</a>(), blocking))
<a name="l00408"></a>00408                                 <span class="keywordflow">return</span> 1;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410                         <span class="keywordtype">bool</span> result = <a class="code" href="class_buffered_transformation.html#8dc8562950fd563f7c62d1f1e5ec6b1e" title="start retrieving the next message">GetNextMessage</a>();
<a name="l00411"></a>00411                         assert(result);
<a name="l00412"></a>00412                 }
<a name="l00413"></a>00413                 <span class="keywordflow">return</span> 0;
<a name="l00414"></a>00414         }
<a name="l00415"></a>00415 }
<a name="l00416"></a>00416 
<a name="l00417"></a><a class="code" href="class_buffered_transformation.html#83945ad467ad20665cfb0a9a9a46ebec">00417</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_buffered_transformation.html#83945ad467ad20665cfb0a9a9a46ebec">BufferedTransformation::CopyMessagesTo</a>(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;target, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count, <span class="keyword">const</span> std::string &amp;channel)<span class="keyword"> const</span>
<a name="l00418"></a>00418 <span class="keyword"></span>{
<a name="l00419"></a>00419         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00420"></a>00420                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#83945ad467ad20665cfb0a9a9a46ebec">CopyMessagesTo</a>(target, count, channel);
<a name="l00421"></a>00421         <span class="keywordflow">else</span>
<a name="l00422"></a>00422                 <span class="keywordflow">return</span> 0;
<a name="l00423"></a>00423 }
<a name="l00424"></a>00424 
<a name="l00425"></a><a class="code" href="class_buffered_transformation.html#aae2c7846a506939b40c2c8b708af1d4">00425</a> <span class="keywordtype">void</span> <a class="code" href="class_buffered_transformation.html#aae2c7846a506939b40c2c8b708af1d4">BufferedTransformation::SkipAll</a>()
<a name="l00426"></a>00426 {
<a name="l00427"></a>00427         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00428"></a>00428                 <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#aae2c7846a506939b40c2c8b708af1d4">SkipAll</a>();
<a name="l00429"></a>00429         <span class="keywordflow">else</span>
<a name="l00430"></a>00430         {
<a name="l00431"></a>00431                 <span class="keywordflow">while</span> (<a class="code" href="class_buffered_transformation.html#ce560f14489f478bb4cd17c41905774e" title="skip count number of messages">SkipMessages</a>()) {}
<a name="l00432"></a>00432                 <span class="keywordflow">while</span> (<a class="code" href="class_buffered_transformation.html#0c25529ded99db20ad35ccef3f7234e6" title="discard skipMax bytes from the output buffer">Skip</a>()) {}
<a name="l00433"></a>00433         }
<a name="l00434"></a>00434 }
<a name="l00435"></a>00435 
<a name="l00436"></a><a class="code" href="class_buffered_transformation.html#e2fac7228d6d06c936f78f0f494aaa3c">00436</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#e2fac7228d6d06c936f78f0f494aaa3c" title="returns the number of bytes left in the current transfer block">BufferedTransformation::TransferAllTo2</a>(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;target, <span class="keyword">const</span> std::string &amp;channel, <span class="keywordtype">bool</span> blocking)
<a name="l00437"></a>00437 {
<a name="l00438"></a>00438         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00439"></a>00439                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#e2fac7228d6d06c936f78f0f494aaa3c" title="returns the number of bytes left in the current transfer block">TransferAllTo2</a>(target, channel, blocking);
<a name="l00440"></a>00440         <span class="keywordflow">else</span>
<a name="l00441"></a>00441         {
<a name="l00442"></a>00442                 assert(!<a class="code" href="class_buffered_transformation.html#d1b83d07c4e05a86e054fbaa32e50468">NumberOfMessageSeries</a>());
<a name="l00443"></a>00443 
<a name="l00444"></a>00444                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> messageCount;
<a name="l00445"></a>00445                 <span class="keywordflow">do</span>
<a name="l00446"></a>00446                 {
<a name="l00447"></a>00447                         messageCount = UINT_MAX;
<a name="l00448"></a>00448                         <span class="keywordtype">size_t</span> blockedBytes = <a class="code" href="class_buffered_transformation.html#0a9ba0f5307ff55f7e1a828188728985" title="upon return, messageCount contains number of messages that have finished being transfered...">TransferMessagesTo2</a>(target, messageCount, channel, blocking);
<a name="l00449"></a>00449                         <span class="keywordflow">if</span> (blockedBytes)
<a name="l00450"></a>00450                                 <span class="keywordflow">return</span> blockedBytes;
<a name="l00451"></a>00451                 }
<a name="l00452"></a>00452                 <span class="keywordflow">while</span> (messageCount != 0);
<a name="l00453"></a>00453 
<a name="l00454"></a>00454                 lword byteCount;
<a name="l00455"></a>00455                 <span class="keywordflow">do</span>
<a name="l00456"></a>00456                 {
<a name="l00457"></a>00457                         byteCount = ULONG_MAX;
<a name="l00458"></a>00458                         <span class="keywordtype">size_t</span> blockedBytes = <a class="code" href="class_buffered_transformation.html#041e8af260c474a43bd232cd4143f406" title="upon return, byteCount contains number of bytes that have finished being transfered...">TransferTo2</a>(target, byteCount, channel, blocking);
<a name="l00459"></a>00459                         <span class="keywordflow">if</span> (blockedBytes)
<a name="l00460"></a>00460                                 <span class="keywordflow">return</span> blockedBytes;
<a name="l00461"></a>00461                 }
<a name="l00462"></a>00462                 <span class="keywordflow">while</span> (byteCount != 0);
<a name="l00463"></a>00463 
<a name="l00464"></a>00464                 <span class="keywordflow">return</span> 0;
<a name="l00465"></a>00465         }
<a name="l00466"></a>00466 }
<a name="l00467"></a>00467 
<a name="l00468"></a><a class="code" href="class_buffered_transformation.html#82c31b089c82fe3ded811b283422aa7c">00468</a> <span class="keywordtype">void</span> <a class="code" href="class_buffered_transformation.html#82c31b089c82fe3ded811b283422aa7c">BufferedTransformation::CopyAllTo</a>(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;target, <span class="keyword">const</span> std::string &amp;channel)<span class="keyword"> const</span>
<a name="l00469"></a>00469 <span class="keyword"></span>{
<a name="l00470"></a>00470         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00471"></a>00471                 <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#82c31b089c82fe3ded811b283422aa7c">CopyAllTo</a>(target, channel);
<a name="l00472"></a>00472         <span class="keywordflow">else</span>
<a name="l00473"></a>00473         {
<a name="l00474"></a>00474                 assert(!<a class="code" href="class_buffered_transformation.html#d1b83d07c4e05a86e054fbaa32e50468">NumberOfMessageSeries</a>());
<a name="l00475"></a>00475                 <span class="keywordflow">while</span> (<a class="code" href="class_buffered_transformation.html#83945ad467ad20665cfb0a9a9a46ebec">CopyMessagesTo</a>(target, UINT_MAX, channel)) {}
<a name="l00476"></a>00476         }
<a name="l00477"></a>00477 }
<a name="l00478"></a>00478 
<a name="l00479"></a><a class="code" href="class_buffered_transformation.html#eeb151c318a472c5f1cf41617f3414a5">00479</a> <span class="keywordtype">void</span> <a class="code" href="class_buffered_transformation.html#eeb151c318a472c5f1cf41617f3414a5">BufferedTransformation::SetRetrievalChannel</a>(<span class="keyword">const</span> std::string &amp;channel)
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00482"></a>00482                 <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#eeb151c318a472c5f1cf41617f3414a5">SetRetrievalChannel</a>(channel);
<a name="l00483"></a>00483 }
<a name="l00484"></a>00484 
<a name="l00485"></a><a class="code" href="class_buffered_transformation.html#a1bca66c16e0e52793059b41353964bd">00485</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#a1bca66c16e0e52793059b41353964bd">BufferedTransformation::ChannelPutWord16</a>(<span class="keyword">const</span> std::string &amp;channel, word16 value, <a class="code" href="cryptlib_8h.html#aeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <span class="keywordtype">bool</span> blocking)
<a name="l00486"></a>00486 {
<a name="l00487"></a>00487         PutWord(<span class="keyword">false</span>, order, m_buf, value);
<a name="l00488"></a>00488         <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#97a60b54fafdb3df59e1457ef629fc5f">ChannelPut</a>(channel, m_buf, 2, blocking);
<a name="l00489"></a>00489 }
<a name="l00490"></a>00490 
<a name="l00491"></a><a class="code" href="class_buffered_transformation.html#cb06216012d6c40609db092952afcf3f">00491</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#cb06216012d6c40609db092952afcf3f">BufferedTransformation::ChannelPutWord32</a>(<span class="keyword">const</span> std::string &amp;channel, word32 value, <a class="code" href="cryptlib_8h.html#aeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <span class="keywordtype">bool</span> blocking)
<a name="l00492"></a>00492 {
<a name="l00493"></a>00493         PutWord(<span class="keyword">false</span>, order, m_buf, value);
<a name="l00494"></a>00494         <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#97a60b54fafdb3df59e1457ef629fc5f">ChannelPut</a>(channel, m_buf, 4, blocking);
<a name="l00495"></a>00495 }
<a name="l00496"></a>00496 
<a name="l00497"></a><a class="code" href="class_buffered_transformation.html#92c60616792d7bce5cd41eaffbd1c3cc">00497</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#92c60616792d7bce5cd41eaffbd1c3cc" title="input a 16-bit word">BufferedTransformation::PutWord16</a>(word16 value, <a class="code" href="cryptlib_8h.html#aeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <span class="keywordtype">bool</span> blocking)
<a name="l00498"></a>00498 {
<a name="l00499"></a>00499         <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#a1bca66c16e0e52793059b41353964bd">ChannelPutWord16</a>(<a class="code" href="class_buffered_transformation.html#5e938c68f2a5e32a03440b1dc2bdc74a">NULL_CHANNEL</a>, value, order, blocking);
<a name="l00500"></a>00500 }
<a name="l00501"></a>00501 
<a name="l00502"></a><a class="code" href="class_buffered_transformation.html#ffcc574867d51528afe3c96721ded075">00502</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#ffcc574867d51528afe3c96721ded075" title="input a 32-bit word">BufferedTransformation::PutWord32</a>(word32 value, <a class="code" href="cryptlib_8h.html#aeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <span class="keywordtype">bool</span> blocking)
<a name="l00503"></a>00503 {
<a name="l00504"></a>00504         <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#cb06216012d6c40609db092952afcf3f">ChannelPutWord32</a>(<a class="code" href="class_buffered_transformation.html#5e938c68f2a5e32a03440b1dc2bdc74a">NULL_CHANNEL</a>, value, order, blocking);
<a name="l00505"></a>00505 }
<a name="l00506"></a>00506 
<a name="l00507"></a><a class="code" href="class_buffered_transformation.html#452057f0d887ba0f2b6ec5373e290e91">00507</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#452057f0d887ba0f2b6ec5373e290e91" title="try to peek at a 16-bit word">BufferedTransformation::PeekWord16</a>(word16 &amp;value, <a class="code" href="cryptlib_8h.html#aeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order)<span class="keyword"> const</span>
<a name="l00508"></a>00508 <span class="keyword"></span>{
<a name="l00509"></a>00509         byte buf[2] = {0, 0};
<a name="l00510"></a>00510         <span class="keywordtype">size_t</span> len = <a class="code" href="class_buffered_transformation.html#5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">Peek</a>(buf, 2);
<a name="l00511"></a>00511 
<a name="l00512"></a>00512         <span class="keywordflow">if</span> (order)
<a name="l00513"></a>00513                 value = (buf[0] &lt;&lt; 8) | buf[1];
<a name="l00514"></a>00514         <span class="keywordflow">else</span>
<a name="l00515"></a>00515                 value = (buf[1] &lt;&lt; 8) | buf[0];
<a name="l00516"></a>00516 
<a name="l00517"></a>00517         <span class="keywordflow">return</span> len;
<a name="l00518"></a>00518 }
<a name="l00519"></a>00519 
<a name="l00520"></a><a class="code" href="class_buffered_transformation.html#ee19b1f5f0df32de2f33bf6bded3bae6">00520</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#ee19b1f5f0df32de2f33bf6bded3bae6" title="try to peek at a 32-bit word">BufferedTransformation::PeekWord32</a>(word32 &amp;value, <a class="code" href="cryptlib_8h.html#aeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order)<span class="keyword"> const</span>
<a name="l00521"></a>00521 <span class="keyword"></span>{
<a name="l00522"></a>00522         byte buf[4] = {0, 0, 0, 0};
<a name="l00523"></a>00523         <span class="keywordtype">size_t</span> len = <a class="code" href="class_buffered_transformation.html#5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">Peek</a>(buf, 4);
<a name="l00524"></a>00524 
<a name="l00525"></a>00525         <span class="keywordflow">if</span> (order)
<a name="l00526"></a>00526                 value = (buf[0] &lt;&lt; 24) | (buf[1] &lt;&lt; 16) | (buf[2] &lt;&lt; 8) | buf [3];
<a name="l00527"></a>00527         <span class="keywordflow">else</span>
<a name="l00528"></a>00528                 value = (buf[3] &lt;&lt; 24) | (buf[2] &lt;&lt; 16) | (buf[1] &lt;&lt; 8) | buf [0];
<a name="l00529"></a>00529 
<a name="l00530"></a>00530         <span class="keywordflow">return</span> len;
<a name="l00531"></a>00531 }
<a name="l00532"></a>00532 
<a name="l00533"></a><a class="code" href="class_buffered_transformation.html#1ac50bcb2d279c3c6aef6858dab3eeb7">00533</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#1ac50bcb2d279c3c6aef6858dab3eeb7" title="try to retrieve a 16-bit word">BufferedTransformation::GetWord16</a>(word16 &amp;value, <a class="code" href="cryptlib_8h.html#aeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order)
<a name="l00534"></a>00534 {
<a name="l00535"></a>00535         <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)<a class="code" href="class_buffered_transformation.html#0c25529ded99db20ad35ccef3f7234e6" title="discard skipMax bytes from the output buffer">Skip</a>(<a class="code" href="class_buffered_transformation.html#452057f0d887ba0f2b6ec5373e290e91" title="try to peek at a 16-bit word">PeekWord16</a>(value, order));
<a name="l00536"></a>00536 }
<a name="l00537"></a>00537 
<a name="l00538"></a><a class="code" href="class_buffered_transformation.html#69c064d931db3a8631c1138827d67e2f">00538</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#69c064d931db3a8631c1138827d67e2f" title="try to retrieve a 32-bit word">BufferedTransformation::GetWord32</a>(word32 &amp;value, <a class="code" href="cryptlib_8h.html#aeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order)
<a name="l00539"></a>00539 {
<a name="l00540"></a>00540         <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)<a class="code" href="class_buffered_transformation.html#0c25529ded99db20ad35ccef3f7234e6" title="discard skipMax bytes from the output buffer">Skip</a>(<a class="code" href="class_buffered_transformation.html#ee19b1f5f0df32de2f33bf6bded3bae6" title="try to peek at a 32-bit word">PeekWord32</a>(value, order));
<a name="l00541"></a>00541 }
<a name="l00542"></a>00542 
<a name="l00543"></a><a class="code" href="class_buffered_transformation.html#9f6cbec970dcb509b23a08fb28b3e055">00543</a> <span class="keywordtype">void</span> <a class="code" href="class_buffered_transformation.html#9f6cbec970dcb509b23a08fb28b3e055" title="add newAttachment to the end of attachment chain">BufferedTransformation::Attach</a>(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *newOut)
<a name="l00544"></a>00544 {
<a name="l00545"></a>00545         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>() &amp;&amp; <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#20112606fc006c56f1561653cabd9542" title="returns whether this object allows attachment">Attachable</a>())
<a name="l00546"></a>00546                 <a class="code" href="class_buffered_transformation.html#ba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#9f6cbec970dcb509b23a08fb28b3e055" title="add newAttachment to the end of attachment chain">Attach</a>(newOut);
<a name="l00547"></a>00547         <span class="keywordflow">else</span>
<a name="l00548"></a>00548                 <a class="code" href="class_buffered_transformation.html#424737ad6b93e393dc43c3edb1223c3d" title="delete the current attachment chain and replace it with newAttachment">Detach</a>(newOut);
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 
<a name="l00551"></a><a class="code" href="class_generatable_crypto_material.html#38d492343c32e530a5c2781b5797f755">00551</a> <span class="keywordtype">void</span> <a class="code" href="class_generatable_crypto_material.html#38d492343c32e530a5c2781b5797f755" title="calls the above function with a NameValuePairs object that just specifies "KeySize"...">GeneratableCryptoMaterial::GenerateRandomWithKeySize</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keySize)
<a name="l00552"></a>00552 {
<a name="l00553"></a>00553         <a class="code" href="class_generatable_crypto_material.html#be368b52db1ca7079b690f2d6e605f7a" title="generate a random key or crypto parameters">GenerateRandom</a>(rng, MakeParameters(<span class="stringliteral">"KeySize"</span>, (<span class="keywordtype">int</span>)keySize));
<a name="l00554"></a>00554 }
<a name="l00555"></a>00555 
<a name="l00556"></a><a class="code" href="class_p_k___default_encryption_filter.html">00556</a> <span class="keyword">class </span><a class="code" href="class_p_k___default_encryption_filter.html">PK_DefaultEncryptionFilter</a> : <span class="keyword">public</span> <a class="code" href="class_unflushable.html" title="_">Unflushable</a>&lt;Filter&gt;
<a name="l00557"></a>00557 {
<a name="l00558"></a>00558 <span class="keyword">public</span>:
<a name="l00559"></a><a class="code" href="class_p_k___default_encryption_filter.html#191cdd32adc348a0f680bff0a28b9978">00559</a>         <a class="code" href="class_p_k___default_encryption_filter.html">PK_DefaultEncryptionFilter</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <span class="keyword">const</span> <a class="code" href="class_p_k___encryptor.html" title="interface for public-key encryptors">PK_Encryptor</a> &amp;encryptor, <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *attachment, <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;parameters)
<a name="l00560"></a>00560                 : m_rng(rng), m_encryptor(encryptor), m_parameters(parameters)
<a name="l00561"></a>00561         {
<a name="l00562"></a>00562                 Detach(attachment);
<a name="l00563"></a>00563         }
<a name="l00564"></a>00564 
<a name="l00565"></a><a class="code" href="class_p_k___default_encryption_filter.html#1e82dd1a02eed0bcf6218829a729904c">00565</a>         <span class="keywordtype">size_t</span> Put2(<span class="keyword">const</span> byte *inString, <span class="keywordtype">size_t</span> length, <span class="keywordtype">int</span> messageEnd, <span class="keywordtype">bool</span> blocking)
<a name="l00566"></a>00566         {
<a name="l00567"></a>00567                 FILTER_BEGIN;
<a name="l00568"></a>00568                 m_plaintextQueue.Put(inString, length);
<a name="l00569"></a>00569 
<a name="l00570"></a>00570                 <span class="keywordflow">if</span> (messageEnd)
<a name="l00571"></a>00571                 {
<a name="l00572"></a>00572                         {
<a name="l00573"></a>00573                         <span class="keywordtype">size_t</span> plaintextLength;
<a name="l00574"></a>00574                         <span class="keywordflow">if</span> (!SafeConvert(m_plaintextQueue.CurrentSize(), plaintextLength))
<a name="l00575"></a>00575                                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(<span class="stringliteral">"PK_DefaultEncryptionFilter: plaintext too long"</span>);
<a name="l00576"></a>00576                         <span class="keywordtype">size_t</span> ciphertextLength = m_encryptor.CiphertextLength(plaintextLength);
<a name="l00577"></a>00577 
<a name="l00578"></a>00578                         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> plaintext(plaintextLength);
<a name="l00579"></a>00579                         m_plaintextQueue.Get(plaintext, plaintextLength);
<a name="l00580"></a>00580                         m_ciphertext.resize(ciphertextLength);
<a name="l00581"></a>00581                         m_encryptor.Encrypt(m_rng, plaintext, plaintextLength, m_ciphertext, m_parameters);
<a name="l00582"></a>00582                         }
<a name="l00583"></a>00583                         
<a name="l00584"></a>00584                         FILTER_OUTPUT(1, m_ciphertext, m_ciphertext.size(), messageEnd);
<a name="l00585"></a>00585                 }
<a name="l00586"></a>00586                 FILTER_END_NO_MESSAGE_END;
<a name="l00587"></a>00587         }
<a name="l00588"></a>00588 
<a name="l00589"></a><a class="code" href="class_p_k___default_encryption_filter.html#8944081b0f33c9f7811c3650eef1bbad">00589</a>         <a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;m_rng;
<a name="l00590"></a><a class="code" href="class_p_k___default_encryption_filter.html#c8a38e097ae12531cff92fbd4bb1680c">00590</a>         <span class="keyword">const</span> <a class="code" href="class_p_k___encryptor.html" title="interface for public-key encryptors">PK_Encryptor</a> &amp;m_encryptor;
<a name="l00591"></a><a class="code" href="class_p_k___default_encryption_filter.html#70c84618dd080b04a6d208dbd4bd6cb6">00591</a>         <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;m_parameters;
<a name="l00592"></a><a class="code" href="class_p_k___default_encryption_filter.html#1d45e75bbe12960bbdd4229691d416a4">00592</a>         <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> m_plaintextQueue;
<a name="l00593"></a><a class="code" href="class_p_k___default_encryption_filter.html#3ef606d5aa57cabf5f594157a99a6ec0">00593</a>         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> m_ciphertext;
<a name="l00594"></a>00594 };
<a name="l00595"></a>00595 
<a name="l00596"></a><a class="code" href="class_p_k___encryptor.html#558cc0f957c7e1e448a746033549964d">00596</a> <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> * <a class="code" href="class_p_k___encryptor.html#558cc0f957c7e1e448a746033549964d" title="create a new encryption filter">PK_Encryptor::CreateEncryptionFilter</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *attachment, <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;parameters)<span class="keyword"> const</span>
<a name="l00597"></a>00597 <span class="keyword"></span>{
<a name="l00598"></a>00598         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_p_k___default_encryption_filter.html">PK_DefaultEncryptionFilter</a>(rng, *<span class="keyword">this</span>, attachment, parameters);
<a name="l00599"></a>00599 }
<a name="l00600"></a>00600 
<a name="l00601"></a><a class="code" href="class_p_k___default_decryption_filter.html">00601</a> <span class="keyword">class </span><a class="code" href="class_p_k___default_decryption_filter.html">PK_DefaultDecryptionFilter</a> : <span class="keyword">public</span> <a class="code" href="class_unflushable.html" title="_">Unflushable</a>&lt;Filter&gt;
<a name="l00602"></a>00602 {
<a name="l00603"></a>00603 <span class="keyword">public</span>:
<a name="l00604"></a><a class="code" href="class_p_k___default_decryption_filter.html#3a1f03ddccd438f7fc03f358caf6cdd6">00604</a>         <a class="code" href="class_p_k___default_decryption_filter.html">PK_DefaultDecryptionFilter</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <span class="keyword">const</span> <a class="code" href="class_p_k___decryptor.html" title="interface for public-key decryptors">PK_Decryptor</a> &amp;decryptor, <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *attachment, <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;parameters)
<a name="l00605"></a>00605                 : m_rng(rng), m_decryptor(decryptor), m_parameters(parameters)
<a name="l00606"></a>00606         {
<a name="l00607"></a>00607                 Detach(attachment);
<a name="l00608"></a>00608         }
<a name="l00609"></a>00609 
<a name="l00610"></a><a class="code" href="class_p_k___default_decryption_filter.html#997075864fd04d41c42a8e8d8361623f">00610</a>         <span class="keywordtype">size_t</span> Put2(<span class="keyword">const</span> byte *inString, <span class="keywordtype">size_t</span> length, <span class="keywordtype">int</span> messageEnd, <span class="keywordtype">bool</span> blocking)
<a name="l00611"></a>00611         {
<a name="l00612"></a>00612                 FILTER_BEGIN;
<a name="l00613"></a>00613                 m_ciphertextQueue.Put(inString, length);
<a name="l00614"></a>00614 
<a name="l00615"></a>00615                 <span class="keywordflow">if</span> (messageEnd)
<a name="l00616"></a>00616                 {
<a name="l00617"></a>00617                         {
<a name="l00618"></a>00618                         <span class="keywordtype">size_t</span> ciphertextLength;
<a name="l00619"></a>00619                         <span class="keywordflow">if</span> (!SafeConvert(m_ciphertextQueue.CurrentSize(), ciphertextLength))
<a name="l00620"></a>00620                                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(<span class="stringliteral">"PK_DefaultDecryptionFilter: ciphertext too long"</span>);
<a name="l00621"></a>00621                         <span class="keywordtype">size_t</span> maxPlaintextLength = m_decryptor.MaxPlaintextLength(ciphertextLength);
<a name="l00622"></a>00622 
<a name="l00623"></a>00623                         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> ciphertext(ciphertextLength);
<a name="l00624"></a>00624                         m_ciphertextQueue.Get(ciphertext, ciphertextLength);
<a name="l00625"></a>00625                         m_plaintext.resize(maxPlaintextLength);
<a name="l00626"></a>00626                         m_result = m_decryptor.Decrypt(m_rng, ciphertext, ciphertextLength, m_plaintext, m_parameters);
<a name="l00627"></a>00627                         <span class="keywordflow">if</span> (!m_result.isValidCoding)
<a name="l00628"></a>00628                                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_ciphertext.html" title="exception thrown by decryption filters when trying to decrypt an invalid ciphertext...">InvalidCiphertext</a>(m_decryptor.AlgorithmName() + <span class="stringliteral">": invalid ciphertext"</span>);
<a name="l00629"></a>00629                         }
<a name="l00630"></a>00630 
<a name="l00631"></a>00631                         FILTER_OUTPUT(1, m_plaintext, m_result.messageLength, messageEnd);
<a name="l00632"></a>00632                 }
<a name="l00633"></a>00633                 FILTER_END_NO_MESSAGE_END;
<a name="l00634"></a>00634         }
<a name="l00635"></a>00635 
<a name="l00636"></a><a class="code" href="class_p_k___default_decryption_filter.html#b90f7a5b69d6988c2ee897fa87b24fd8">00636</a>         <a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;m_rng;
<a name="l00637"></a><a class="code" href="class_p_k___default_decryption_filter.html#f3f3e9f559705c7e95ae70cbe3894ec4">00637</a>         <span class="keyword">const</span> <a class="code" href="class_p_k___decryptor.html" title="interface for public-key decryptors">PK_Decryptor</a> &amp;m_decryptor;
<a name="l00638"></a><a class="code" href="class_p_k___default_decryption_filter.html#8131b1fcb90fb4bebcad4902e99b2349">00638</a>         <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;m_parameters;
<a name="l00639"></a><a class="code" href="class_p_k___default_decryption_filter.html#fe35453e67180ffddc47a0be267268da">00639</a>         <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> m_ciphertextQueue;
<a name="l00640"></a><a class="code" href="class_p_k___default_decryption_filter.html#824de8ddc8d14112d42a1c5e7a8f2e80">00640</a>         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> m_plaintext;
<a name="l00641"></a><a class="code" href="class_p_k___default_decryption_filter.html#0bd6f7a1cbaab9e42857c4c5ef763c53">00641</a>         <a class="code" href="struct_decoding_result.html" title="used to return decoding results">DecodingResult</a> m_result;
<a name="l00642"></a>00642 };
<a name="l00643"></a>00643 
<a name="l00644"></a><a class="code" href="class_p_k___decryptor.html#c98bd1dac38f73bdc7d0930053ce9f56">00644</a> <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> * <a class="code" href="class_p_k___decryptor.html#c98bd1dac38f73bdc7d0930053ce9f56" title="create a new decryption filter">PK_Decryptor::CreateDecryptionFilter</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *attachment, <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;parameters)<span class="keyword"> const</span>
<a name="l00645"></a>00645 <span class="keyword"></span>{
<a name="l00646"></a>00646         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_p_k___default_decryption_filter.html">PK_DefaultDecryptionFilter</a>(rng, *<span class="keyword">this</span>, attachment, parameters);
<a name="l00647"></a>00647 }
<a name="l00648"></a>00648 
<a name="l00649"></a><a class="code" href="class_p_k___signer.html#28de428238711210d765b6389062e6e2">00649</a> <span class="keywordtype">size_t</span> <a class="code" href="class_p_k___signer.html#28de428238711210d765b6389062e6e2" title="sign and delete messageAccumulator (even in case of exception thrown)">PK_Signer::Sign</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <a class="code" href="class_p_k___message_accumulator.html" title="interface for accumulating messages to be signed or verified">PK_MessageAccumulator</a> *messageAccumulator, byte *signature)<span class="keyword"> const</span>
<a name="l00650"></a>00650 <span class="keyword"></span>{
<a name="l00651"></a>00651         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(messageAccumulator);
<a name="l00652"></a>00652         <span class="keywordflow">return</span> <a class="code" href="class_p_k___signer.html#fbcf3f00d761f681839ae6264743dd34" title="sign and restart messageAccumulator">SignAndRestart</a>(rng, *m, signature, <span class="keyword">false</span>);
<a name="l00653"></a>00653 }
<a name="l00654"></a>00654 
<a name="l00655"></a><a class="code" href="class_p_k___signer.html#6781cdd4a4a750a9720e268c90a24387">00655</a> <span class="keywordtype">size_t</span> <a class="code" href="class_p_k___signer.html#6781cdd4a4a750a9720e268c90a24387" title="sign a message">PK_Signer::SignMessage</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <span class="keyword">const</span> byte *message, <span class="keywordtype">size_t</span> messageLen, byte *signature)<span class="keyword"> const</span>
<a name="l00656"></a>00656 <span class="keyword"></span>{
<a name="l00657"></a>00657         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(<a class="code" href="class_p_k___signer.html#ff85d006e814ccc8ac943b145a0bfaf9" title="create a new HashTransformation to accumulate the message to be signed">NewSignatureAccumulator</a>(rng));
<a name="l00658"></a>00658         m-&gt;Update(message, messageLen);
<a name="l00659"></a>00659         <span class="keywordflow">return</span> <a class="code" href="class_p_k___signer.html#fbcf3f00d761f681839ae6264743dd34" title="sign and restart messageAccumulator">SignAndRestart</a>(rng, *m, signature, <span class="keyword">false</span>);
<a name="l00660"></a>00660 }
<a name="l00661"></a>00661 
<a name="l00662"></a><a class="code" href="class_p_k___signer.html#76eb862d0cb8d80e0bee7ad52a0da707">00662</a> <span class="keywordtype">size_t</span> <a class="code" href="class_p_k___signer.html#76eb862d0cb8d80e0bee7ad52a0da707" title="sign a recoverable message">PK_Signer::SignMessageWithRecovery</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <span class="keyword">const</span> byte *recoverableMessage, <span class="keywordtype">size_t</span> recoverableMessageLength, 
<a name="l00663"></a>00663         <span class="keyword">const</span> byte *nonrecoverableMessage, <span class="keywordtype">size_t</span> nonrecoverableMessageLength, byte *signature)<span class="keyword"> const</span>
<a name="l00664"></a>00664 <span class="keyword"></span>{
<a name="l00665"></a>00665         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(<a class="code" href="class_p_k___signer.html#ff85d006e814ccc8ac943b145a0bfaf9" title="create a new HashTransformation to accumulate the message to be signed">NewSignatureAccumulator</a>(rng));
<a name="l00666"></a>00666         InputRecoverableMessage(*m, recoverableMessage, recoverableMessageLength);
<a name="l00667"></a>00667         m-&gt;Update(nonrecoverableMessage, nonrecoverableMessageLength);
<a name="l00668"></a>00668         <span class="keywordflow">return</span> <a class="code" href="class_p_k___signer.html#fbcf3f00d761f681839ae6264743dd34" title="sign and restart messageAccumulator">SignAndRestart</a>(rng, *m, signature, <span class="keyword">false</span>);
<a name="l00669"></a>00669 }
<a name="l00670"></a>00670 
<a name="l00671"></a><a class="code" href="class_p_k___verifier.html#002461c71eaacb022a0d169975a6f752">00671</a> <span class="keywordtype">bool</span> <a class="code" href="class_p_k___verifier.html#002461c71eaacb022a0d169975a6f752" title="check whether messageAccumulator contains a valid signature and message, and delete...">PK_Verifier::Verify</a>(<a class="code" href="class_p_k___message_accumulator.html" title="interface for accumulating messages to be signed or verified">PK_MessageAccumulator</a> *messageAccumulator)<span class="keyword"> const</span>
<a name="l00672"></a>00672 <span class="keyword"></span>{
<a name="l00673"></a>00673         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(messageAccumulator);
<a name="l00674"></a>00674         <span class="keywordflow">return</span> <a class="code" href="class_p_k___verifier.html#36e176dc8a0d3f924938cb2b07021f28" title="check whether messageAccumulator contains a valid signature and message, and restart...">VerifyAndRestart</a>(*m);
<a name="l00675"></a>00675 }
<a name="l00676"></a>00676 
<a name="l00677"></a><a class="code" href="class_p_k___verifier.html#4640a967fd291f8be86c1b721dc73b2d">00677</a> <span class="keywordtype">bool</span> <a class="code" href="class_p_k___verifier.html#4640a967fd291f8be86c1b721dc73b2d" title="check whether input signature is a valid signature for input message">PK_Verifier::VerifyMessage</a>(<span class="keyword">const</span> byte *message, <span class="keywordtype">size_t</span> messageLen, <span class="keyword">const</span> byte *signature, <span class="keywordtype">size_t</span> signatureLength)<span class="keyword"> const</span>
<a name="l00678"></a>00678 <span class="keyword"></span>{
<a name="l00679"></a>00679         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(<a class="code" href="class_p_k___verifier.html#24203e25fdd33fa7cf3c4a2393444a78" title="create a new HashTransformation to accumulate the message to be verified">NewVerificationAccumulator</a>());
<a name="l00680"></a>00680         <a class="code" href="class_p_k___verifier.html#515aa448e7fc3a5c6e422e65500ab507" title="input signature into a message accumulator">InputSignature</a>(*m, signature, signatureLength);
<a name="l00681"></a>00681         m-&gt;Update(message, messageLen);
<a name="l00682"></a>00682         <span class="keywordflow">return</span> <a class="code" href="class_p_k___verifier.html#36e176dc8a0d3f924938cb2b07021f28" title="check whether messageAccumulator contains a valid signature and message, and restart...">VerifyAndRestart</a>(*m);
<a name="l00683"></a>00683 }
<a name="l00684"></a>00684 
<a name="l00685"></a><a class="code" href="class_p_k___verifier.html#25a928c76d7bc73e1a04d85266b46382">00685</a> <a class="code" href="struct_decoding_result.html" title="used to return decoding results">DecodingResult</a> <a class="code" href="class_p_k___verifier.html#25a928c76d7bc73e1a04d85266b46382" title="recover a message from its signature">PK_Verifier::Recover</a>(byte *recoveredMessage, <a class="code" href="class_p_k___message_accumulator.html" title="interface for accumulating messages to be signed or verified">PK_MessageAccumulator</a> *messageAccumulator)<span class="keyword"> const</span>
<a name="l00686"></a>00686 <span class="keyword"></span>{
<a name="l00687"></a>00687         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(messageAccumulator);
<a name="l00688"></a>00688         <span class="keywordflow">return</span> <a class="code" href="class_p_k___verifier.html#6612ff44a274594890419ae75d260cce" title="recover a message from its signature">RecoverAndRestart</a>(recoveredMessage, *m);
<a name="l00689"></a>00689 }
<a name="l00690"></a>00690 
<a name="l00691"></a><a class="code" href="class_p_k___verifier.html#05d969651d86a63d5002057113e0cab7">00691</a> <a class="code" href="struct_decoding_result.html" title="used to return decoding results">DecodingResult</a> <a class="code" href="class_p_k___verifier.html#05d969651d86a63d5002057113e0cab7" title="recover a message from its signature">PK_Verifier::RecoverMessage</a>(byte *recoveredMessage, 
<a name="l00692"></a>00692         <span class="keyword">const</span> byte *nonrecoverableMessage, <span class="keywordtype">size_t</span> nonrecoverableMessageLength, 
<a name="l00693"></a>00693         <span class="keyword">const</span> byte *signature, <span class="keywordtype">size_t</span> signatureLength)<span class="keyword"> const</span>
<a name="l00694"></a>00694 <span class="keyword"></span>{
<a name="l00695"></a>00695         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(<a class="code" href="class_p_k___verifier.html#24203e25fdd33fa7cf3c4a2393444a78" title="create a new HashTransformation to accumulate the message to be verified">NewVerificationAccumulator</a>());
<a name="l00696"></a>00696         <a class="code" href="class_p_k___verifier.html#515aa448e7fc3a5c6e422e65500ab507" title="input signature into a message accumulator">InputSignature</a>(*m, signature, signatureLength);
<a name="l00697"></a>00697         m-&gt;Update(nonrecoverableMessage, nonrecoverableMessageLength);
<a name="l00698"></a>00698         <span class="keywordflow">return</span> <a class="code" href="class_p_k___verifier.html#6612ff44a274594890419ae75d260cce" title="recover a message from its signature">RecoverAndRestart</a>(recoveredMessage, *m);
<a name="l00699"></a>00699 }
<a name="l00700"></a>00700 
<a name="l00701"></a><a class="code" href="class_simple_key_agreement_domain.html#75629cd8157dca667c6aff0562ca59af">00701</a> <span class="keywordtype">void</span> <a class="code" href="class_simple_key_agreement_domain.html#75629cd8157dca667c6aff0562ca59af" title="generate private/public key pair">SimpleKeyAgreementDomain::GenerateKeyPair</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, byte *privateKey, byte *publicKey)<span class="keyword"> const</span>
<a name="l00702"></a>00702 <span class="keyword"></span>{
<a name="l00703"></a>00703         <a class="code" href="class_simple_key_agreement_domain.html#ee7a4929f8a1a77acd04e12fbcd0a0b1" title="generate private key">GeneratePrivateKey</a>(rng, privateKey);
<a name="l00704"></a>00704         <a class="code" href="class_simple_key_agreement_domain.html#56d0957a43c48f3e6431868f564f574f" title="generate public key">GeneratePublicKey</a>(rng, privateKey, publicKey);
<a name="l00705"></a>00705 }
<a name="l00706"></a>00706 
<a name="l00707"></a><a class="code" href="class_authenticated_key_agreement_domain.html#e2c306a6582c6e592ecb2c13abfd7c9f">00707</a> <span class="keywordtype">void</span> <a class="code" href="class_authenticated_key_agreement_domain.html#e2c306a6582c6e592ecb2c13abfd7c9f" title="generate private/public key pair">AuthenticatedKeyAgreementDomain::GenerateStaticKeyPair</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, byte *privateKey, byte *publicKey)<span class="keyword"> const</span>
<a name="l00708"></a>00708 <span class="keyword"></span>{
<a name="l00709"></a>00709         <a class="code" href="class_authenticated_key_agreement_domain.html#00d9b12028e9ecb61af6d0f312965c6f" title="generate static private key">GenerateStaticPrivateKey</a>(rng, privateKey);
<a name="l00710"></a>00710         <a class="code" href="class_authenticated_key_agreement_domain.html#853885a901ac7c4f8c51fd177df5d96c" title="generate static public key">GenerateStaticPublicKey</a>(rng, privateKey, publicKey);
<a name="l00711"></a>00711 }
<a name="l00712"></a>00712 
<a name="l00713"></a><a class="code" href="class_authenticated_key_agreement_domain.html#18f1fc5fa590be704d53759e44fba093">00713</a> <span class="keywordtype">void</span> <a class="code" href="class_authenticated_key_agreement_domain.html#18f1fc5fa590be704d53759e44fba093" title="generate private/public key pair">AuthenticatedKeyAgreementDomain::GenerateEphemeralKeyPair</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, byte *privateKey, byte *publicKey)<span class="keyword"> const</span>
<a name="l00714"></a>00714 <span class="keyword"></span>{
<a name="l00715"></a>00715         <a class="code" href="class_authenticated_key_agreement_domain.html#b6280d3bf8ad1dd2aa976910b81502f8" title="generate ephemeral private key">GenerateEphemeralPrivateKey</a>(rng, privateKey);
<a name="l00716"></a>00716         <a class="code" href="class_authenticated_key_agreement_domain.html#9d1bc83a77f44af6616da42c33b3bc49" title="generate ephemeral public key">GenerateEphemeralPublicKey</a>(rng, privateKey, publicKey);
<a name="l00717"></a>00717 }
<a name="l00718"></a>00718 
<a name="l00719"></a>00719 NAMESPACE_END
<a name="l00720"></a>00720 
<a name="l00721"></a>00721 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 11:11:20 2007 for Crypto++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
