<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Crypto++: validat2.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>validat2.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// validat2.cpp - written and placed in the public domain by Wei Dai</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include "pch.h"</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="preprocessor">#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1</span>
<a name="l00006"></a>00006 <span class="preprocessor"></span><span class="preprocessor">#include "blumshub.h"</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "<a class="code" href="rsa_8h.html" title="This file contains classes that implement the RSA ciphers and signature schemes as...">rsa.h</a>"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "md2.h"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "elgamal.h"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "nr.h"</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "<a class="code" href="dsa_8h.html">dsa.h</a>"</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include "<a class="code" href="dh_8h.html">dh.h</a>"</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include "<a class="code" href="mqv_8h.html">mqv.h</a>"</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include "<a class="code" href="luc_8h.html">luc.h</a>"</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include "<a class="code" href="xtrcrypt_8h.html" title=""The XTR public key system" by Arjen K.">xtrcrypt.h</a>"</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include "<a class="code" href="rabin_8h.html">rabin.h</a>"</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include "<a class="code" href="rw_8h.html" title="This file contains classes that implement the Rabin-Williams signature schemes as...">rw.h</a>"</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include "<a class="code" href="eccrypto_8h.html">eccrypto.h</a>"</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include "ecp.h"</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include "ec2n.h"</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include "asn.h"</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include "rng.h"</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include "files.h"</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include "hex.h"</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include "oids.h"</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include "<a class="code" href="esign_8h.html" title="This file contains classes that implement the ESIGN signature schemes as defined...">esign.h</a>"</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include "osrng.h"</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include "validate.h"</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 USING_NAMESPACE(CryptoPP)
<a name="l00035"></a>00035 USING_NAMESPACE(std)
<a name="l00036"></a>00036 
<a name="l00037"></a><a class="code" href="class_fixed_r_n_g.html">00037</a> class <a class="code" href="class_fixed_r_n_g.html">FixedRNG</a> : public <a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a>
<a name="l00038"></a>00038 {
<a name="l00039"></a>00039 <span class="keyword">public</span>:
<a name="l00040"></a><a class="code" href="class_fixed_r_n_g.html#5189d8e0044f74c44ab433eb69a9b95d">00040</a>         <a class="code" href="class_fixed_r_n_g.html">FixedRNG</a>(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;source) : m_source(source) {}
<a name="l00041"></a>00041 
<a name="l00042"></a><a class="code" href="class_fixed_r_n_g.html#93c800795dea0f52681dc6d4d7f254eb">00042</a>         <span class="keywordtype">void</span> GenerateBlock(byte *output, <span class="keywordtype">size_t</span> size)
<a name="l00043"></a>00043         {
<a name="l00044"></a>00044                 m_source.Get(output, size);
<a name="l00045"></a>00045         }
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="keyword">private</span>:
<a name="l00048"></a>00048         <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;m_source;
<a name="l00049"></a>00049 };
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="keywordtype">bool</span> ValidateBBS()
<a name="l00052"></a>00052 {
<a name="l00053"></a>00053         cout &lt;&lt; <span class="stringliteral">"\nBlumBlumShub validation suite running...\n\n"</span>;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> p(<span class="stringliteral">"212004934506826557583707108431463840565872545889679278744389317666981496005411448865750399674653351"</span>);
<a name="l00056"></a>00056         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> q(<span class="stringliteral">"100677295735404212434355574418077394581488455772477016953458064183204108039226017738610663984508231"</span>);
<a name="l00057"></a>00057         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> seed(<span class="stringliteral">"63239752671357255800299643604761065219897634268887145610573595874544114193025997412441121667211431"</span>);
<a name="l00058"></a>00058         <a class="code" href="class_blum_blum_shub.html" title="BlumBlumShub with factorization of the modulus.">BlumBlumShub</a> bbs(p, q, seed);
<a name="l00059"></a>00059         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>, fail;
<a name="l00060"></a>00060         <span class="keywordtype">int</span> j;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062         <span class="keyword">const</span> byte output1[] = {
<a name="l00063"></a>00063                 0x49,0xEA,0x2C,0xFD,0xB0,0x10,0x64,0xA0,0xBB,0xB9,
<a name="l00064"></a>00064                 0x2A,0xF1,0x01,0xDA,0xC1,0x8A,0x94,0xF7,0xB7,0xCE};
<a name="l00065"></a>00065         <span class="keyword">const</span> byte output2[] = {
<a name="l00066"></a>00066                 0x74,0x45,0x48,0xAE,0xAC,0xB7,0x0E,0xDF,0xAF,0xD7,
<a name="l00067"></a>00067                 0xD5,0x0E,0x8E,0x29,0x83,0x75,0x6B,0x27,0x46,0xA1};
<a name="l00068"></a>00068 
<a name="l00069"></a>00069         byte buf[20];
<a name="l00070"></a>00070 
<a name="l00071"></a>00071         bbs.GenerateBlock(buf, 20);
<a name="l00072"></a>00072         fail = memcmp(output1, buf, 20) != 0;
<a name="l00073"></a>00073         pass = pass &amp;&amp; !fail;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00076"></a>00076         <span class="keywordflow">for</span> (j=0;j&lt;20;j++)
<a name="l00077"></a>00077                 cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">'0'</span>) &lt;&lt; hex &lt;&lt; (<span class="keywordtype">int</span>)buf[j];
<a name="l00078"></a>00078         cout &lt;&lt; endl;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080         bbs.Seek(10);
<a name="l00081"></a>00081         bbs.GenerateBlock(buf, 10);
<a name="l00082"></a>00082         fail = memcmp(output1+10, buf, 10) != 0;
<a name="l00083"></a>00083         pass = pass &amp;&amp; !fail;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00086"></a>00086         <span class="keywordflow">for</span> (j=0;j&lt;10;j++)
<a name="l00087"></a>00087                 cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">'0'</span>) &lt;&lt; hex &lt;&lt; (<span class="keywordtype">int</span>)buf[j];
<a name="l00088"></a>00088         cout &lt;&lt; endl;
<a name="l00089"></a>00089 
<a name="l00090"></a>00090         bbs.Seek(1234567);
<a name="l00091"></a>00091         bbs.GenerateBlock(buf, 20);
<a name="l00092"></a>00092         fail = memcmp(output2, buf, 20) != 0;
<a name="l00093"></a>00093         pass = pass &amp;&amp; !fail;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00096"></a>00096         <span class="keywordflow">for</span> (j=0;j&lt;20;j++)
<a name="l00097"></a>00097                 cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">'0'</span>) &lt;&lt; hex &lt;&lt; (<span class="keywordtype">int</span>)buf[j];
<a name="l00098"></a>00098         cout &lt;&lt; endl;
<a name="l00099"></a>00099 
<a name="l00100"></a>00100         <span class="keywordflow">return</span> pass;
<a name="l00101"></a>00101 }
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="keywordtype">bool</span> SignatureValidate(<a class="code" href="class_p_k___signer.html" title="interface for public-key signers">PK_Signer</a> &amp;priv, <a class="code" href="class_p_k___verifier.html" title="interface for public-key signature verifiers">PK_Verifier</a> &amp;pub, <span class="keywordtype">bool</span> thorough = <span class="keyword">false</span>)
<a name="l00104"></a>00104 {
<a name="l00105"></a>00105         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>, fail;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         fail = !pub.<a class="code" href="class_public_key_algorithm.html#8c2bb02751348ff151ad9d4756cafd74" title="returns a const reference to the crypto material used by this object">GetMaterial</a>().<a class="code" href="class_crypto_material.html#439743c6b4e89ca8228a12fa1ea43ab1" title="check this object for errors">Validate</a>(GlobalRNG(), thorough ? 3 : 2) || !priv.<a class="code" href="class_private_key_algorithm.html#59f3867165685cc6ac6be3f53d5f371b" title="returns a const reference to the crypto material used by this object">GetMaterial</a>().<a class="code" href="class_crypto_material.html#439743c6b4e89ca8228a12fa1ea43ab1" title="check this object for errors">Validate</a>(GlobalRNG(), thorough ? 3 : 2);
<a name="l00108"></a>00108         pass = pass &amp;&amp; !fail;
<a name="l00109"></a>00109 
<a name="l00110"></a>00110         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00111"></a>00111         cout &lt;&lt; <span class="stringliteral">"signature key validation\n"</span>;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113         <span class="keyword">const</span> byte *message = (byte *)<span class="stringliteral">"test message"</span>;
<a name="l00114"></a>00114         <span class="keyword">const</span> <span class="keywordtype">int</span> messageLen = 12;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> signature(priv.<a class="code" href="class_p_k___signature_scheme.html#665909c10f27db81343a01c814488652" title="maximum signature length produced for a given length of recoverable message part">MaxSignatureLength</a>());
<a name="l00117"></a>00117         <span class="keywordtype">size_t</span> signatureLength = priv.<a class="code" href="class_p_k___signer.html#6781cdd4a4a750a9720e268c90a24387" title="sign a message">SignMessage</a>(GlobalRNG(), message, messageLen, signature);
<a name="l00118"></a>00118         fail = !pub.<a class="code" href="class_p_k___verifier.html#4640a967fd291f8be86c1b721dc73b2d" title="check whether input signature is a valid signature for input message">VerifyMessage</a>(message, messageLen, signature, signatureLength);
<a name="l00119"></a>00119         pass = pass &amp;&amp; !fail;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00122"></a>00122         cout &lt;&lt; <span class="stringliteral">"signature and verification\n"</span>;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         ++signature[0];
<a name="l00125"></a>00125         fail = pub.<a class="code" href="class_p_k___verifier.html#4640a967fd291f8be86c1b721dc73b2d" title="check whether input signature is a valid signature for input message">VerifyMessage</a>(message, messageLen, signature, signatureLength);
<a name="l00126"></a>00126         pass = pass &amp;&amp; !fail;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00129"></a>00129         cout &lt;&lt; <span class="stringliteral">"checking invalid signature"</span> &lt;&lt; endl;
<a name="l00130"></a>00130 
<a name="l00131"></a>00131         <span class="keywordflow">if</span> (priv.<a class="code" href="class_p_k___signature_scheme.html#f8f3fd3692c258b72be3dad6da3423ec" title="length of longest message that can be recovered, or 0 if this signature scheme does...">MaxRecoverableLength</a>() &gt; 0)
<a name="l00132"></a>00132         {
<a name="l00133"></a>00133                 signatureLength = priv.<a class="code" href="class_p_k___signer.html#76eb862d0cb8d80e0bee7ad52a0da707" title="sign a recoverable message">SignMessageWithRecovery</a>(GlobalRNG(), message, messageLen, NULL, 0, signature);
<a name="l00134"></a>00134                 <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> recovered(priv.<a class="code" href="class_p_k___signature_scheme.html#2f2a599ba385e63766d4a7f7ccf2a884" title="length of longest message that can be recovered from a signature of given length...">MaxRecoverableLengthFromSignatureLength</a>(signatureLength));
<a name="l00135"></a>00135                 <a class="code" href="struct_decoding_result.html" title="used to return decoding results">DecodingResult</a> result = pub.<a class="code" href="class_p_k___verifier.html#05d969651d86a63d5002057113e0cab7" title="recover a message from its signature">RecoverMessage</a>(recovered, NULL, 0, signature, signatureLength);
<a name="l00136"></a>00136                 fail = !(result.isValidCoding &amp;&amp; result.messageLength == messageLen &amp;&amp; memcmp(recovered, message, messageLen) == 0);
<a name="l00137"></a>00137                 pass = pass &amp;&amp; !fail;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139                 cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00140"></a>00140                 cout &lt;&lt; <span class="stringliteral">"signature and verification with recovery"</span> &lt;&lt; endl;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142                 ++signature[0];
<a name="l00143"></a>00143                 result = pub.<a class="code" href="class_p_k___verifier.html#05d969651d86a63d5002057113e0cab7" title="recover a message from its signature">RecoverMessage</a>(recovered, NULL, 0, signature, signatureLength);
<a name="l00144"></a>00144                 fail = result.<a class="code" href="struct_decoding_result.html#b88062318cd0e68b3061db351d3ba34d">isValidCoding</a>;
<a name="l00145"></a>00145                 pass = pass &amp;&amp; !fail;
<a name="l00146"></a>00146 
<a name="l00147"></a>00147                 cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00148"></a>00148                 cout &lt;&lt; <span class="stringliteral">"recovery with invalid signature"</span> &lt;&lt; endl;
<a name="l00149"></a>00149         }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151         <span class="keywordflow">return</span> pass;
<a name="l00152"></a>00152 }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keywordtype">bool</span> CryptoSystemValidate(<a class="code" href="class_p_k___decryptor.html" title="interface for public-key decryptors">PK_Decryptor</a> &amp;priv, <a class="code" href="class_p_k___encryptor.html" title="interface for public-key encryptors">PK_Encryptor</a> &amp;pub, <span class="keywordtype">bool</span> thorough = <span class="keyword">false</span>)
<a name="l00155"></a>00155 {
<a name="l00156"></a>00156         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>, fail;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158         fail = !pub.<a class="code" href="class_public_key_algorithm.html#8c2bb02751348ff151ad9d4756cafd74" title="returns a const reference to the crypto material used by this object">GetMaterial</a>().<a class="code" href="class_crypto_material.html#439743c6b4e89ca8228a12fa1ea43ab1" title="check this object for errors">Validate</a>(GlobalRNG(), thorough ? 3 : 2) || !priv.<a class="code" href="class_private_key_algorithm.html#59f3867165685cc6ac6be3f53d5f371b" title="returns a const reference to the crypto material used by this object">GetMaterial</a>().<a class="code" href="class_crypto_material.html#439743c6b4e89ca8228a12fa1ea43ab1" title="check this object for errors">Validate</a>(GlobalRNG(), thorough ? 3 : 2);
<a name="l00159"></a>00159         pass = pass &amp;&amp; !fail;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00162"></a>00162         cout &lt;&lt; <span class="stringliteral">"cryptosystem key validation\n"</span>;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164         <span class="keyword">const</span> byte *message = (byte *)<span class="stringliteral">"test message"</span>;
<a name="l00165"></a>00165         <span class="keyword">const</span> <span class="keywordtype">int</span> messageLen = 12;
<a name="l00166"></a>00166         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> ciphertext(priv.<a class="code" href="class_p_k___crypto_system.html#bf04a4e08fb69a1a118bad3e998ef6a6" title="calculate length of ciphertext given length of plaintext">CiphertextLength</a>(messageLen));
<a name="l00167"></a>00167         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> plaintext(priv.<a class="code" href="class_p_k___crypto_system.html#a4a3552c933a36b3aea26f31d00bee9b" title="maximum length of plaintext for a given ciphertext length">MaxPlaintextLength</a>(ciphertext.size()));
<a name="l00168"></a>00168 
<a name="l00169"></a>00169         pub.<a class="code" href="class_p_k___encryptor.html#42361bf7692153da9437802df4064258" title="encrypt a byte string">Encrypt</a>(GlobalRNG(), message, messageLen, ciphertext);
<a name="l00170"></a>00170         fail = priv.<a class="code" href="class_p_k___decryptor.html#b7466675ed050c440c16508f8a88cac1" title="decrypt a byte string, and return the length of plaintext">Decrypt</a>(GlobalRNG(), ciphertext, priv.<a class="code" href="class_p_k___crypto_system.html#bf04a4e08fb69a1a118bad3e998ef6a6" title="calculate length of ciphertext given length of plaintext">CiphertextLength</a>(messageLen), plaintext) != <a class="code" href="struct_decoding_result.html" title="used to return decoding results">DecodingResult</a>(messageLen);
<a name="l00171"></a>00171         fail = fail || memcmp(message, plaintext, messageLen);
<a name="l00172"></a>00172         pass = pass &amp;&amp; !fail;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00175"></a>00175         cout &lt;&lt; <span class="stringliteral">"encryption and decryption\n"</span>;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177         <span class="keywordflow">return</span> pass;
<a name="l00178"></a>00178 }
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 <span class="keywordtype">bool</span> SimpleKeyAgreementValidate(<a class="code" href="class_simple_key_agreement_domain.html" title="interface for domains of simple key agreement protocols">SimpleKeyAgreementDomain</a> &amp;d)
<a name="l00181"></a>00181 {
<a name="l00182"></a>00182         <span class="keywordflow">if</span> (d.<a class="code" href="class_key_agreement_algorithm.html#5b0e622b88d0b8d319c23e4aefef414d">GetCryptoParameters</a>().<a class="code" href="class_crypto_material.html#439743c6b4e89ca8228a12fa1ea43ab1" title="check this object for errors">Validate</a>(GlobalRNG(), 3))
<a name="l00183"></a>00183                 cout &lt;&lt; <span class="stringliteral">"passed    simple key agreement domain parameters validation"</span> &lt;&lt; endl;
<a name="l00184"></a>00184         <span class="keywordflow">else</span>
<a name="l00185"></a>00185         {
<a name="l00186"></a>00186                 cout &lt;&lt; <span class="stringliteral">"FAILED    simple key agreement domain parameters invalid"</span> &lt;&lt; endl;
<a name="l00187"></a>00187                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> priv1(d.<a class="code" href="class_simple_key_agreement_domain.html#131fa4e8260ec044fc12a540e8470325" title="return length of private keys in this domain">PrivateKeyLength</a>()), priv2(d.<a class="code" href="class_simple_key_agreement_domain.html#131fa4e8260ec044fc12a540e8470325" title="return length of private keys in this domain">PrivateKeyLength</a>());
<a name="l00191"></a>00191         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> pub1(d.<a class="code" href="class_simple_key_agreement_domain.html#0a96f98bb61ae0777604e035e7984bd1" title="return length of public keys in this domain">PublicKeyLength</a>()), pub2(d.<a class="code" href="class_simple_key_agreement_domain.html#0a96f98bb61ae0777604e035e7984bd1" title="return length of public keys in this domain">PublicKeyLength</a>());
<a name="l00192"></a>00192         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> val1(d.<a class="code" href="class_simple_key_agreement_domain.html#fbf257cf0f75e66070e2636939e9c2ca" title="return length of agreed value produced">AgreedValueLength</a>()), val2(d.<a class="code" href="class_simple_key_agreement_domain.html#fbf257cf0f75e66070e2636939e9c2ca" title="return length of agreed value produced">AgreedValueLength</a>());
<a name="l00193"></a>00193 
<a name="l00194"></a>00194         d.<a class="code" href="class_simple_key_agreement_domain.html#75629cd8157dca667c6aff0562ca59af" title="generate private/public key pair">GenerateKeyPair</a>(GlobalRNG(), priv1, pub1);
<a name="l00195"></a>00195         d.<a class="code" href="class_simple_key_agreement_domain.html#75629cd8157dca667c6aff0562ca59af" title="generate private/public key pair">GenerateKeyPair</a>(GlobalRNG(), priv2, pub2);
<a name="l00196"></a>00196 
<a name="l00197"></a>00197         memset(val1.begin(), 0x10, val1.size());
<a name="l00198"></a>00198         memset(val2.begin(), 0x11, val2.size());
<a name="l00199"></a>00199 
<a name="l00200"></a>00200         <span class="keywordflow">if</span> (!(d.<a class="code" href="class_simple_key_agreement_domain.html#732339ca730408cca7b1191fc32eb39e" title="derive agreed value from your private key and couterparty's public key, return false...">Agree</a>(val1, priv1, pub2) &amp;&amp; d.<a class="code" href="class_simple_key_agreement_domain.html#732339ca730408cca7b1191fc32eb39e" title="derive agreed value from your private key and couterparty's public key, return false...">Agree</a>(val2, priv2, pub1)))
<a name="l00201"></a>00201         {
<a name="l00202"></a>00202                 cout &lt;&lt; <span class="stringliteral">"FAILED    simple key agreement failed"</span> &lt;&lt; endl;
<a name="l00203"></a>00203                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00204"></a>00204         }
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         <span class="keywordflow">if</span> (memcmp(val1.begin(), val2.begin(), d.<a class="code" href="class_simple_key_agreement_domain.html#fbf257cf0f75e66070e2636939e9c2ca" title="return length of agreed value produced">AgreedValueLength</a>()))
<a name="l00207"></a>00207         {
<a name="l00208"></a>00208                 cout &lt;&lt; <span class="stringliteral">"FAILED    simple agreed values not equal"</span> &lt;&lt; endl;
<a name="l00209"></a>00209                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00210"></a>00210         }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212         cout &lt;&lt; <span class="stringliteral">"passed    simple key agreement"</span> &lt;&lt; endl;
<a name="l00213"></a>00213         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00214"></a>00214 }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 <span class="keywordtype">bool</span> AuthenticatedKeyAgreementValidate(<a class="code" href="class_authenticated_key_agreement_domain.html" title="interface for domains of authenticated key agreement protocols">AuthenticatedKeyAgreementDomain</a> &amp;d)
<a name="l00217"></a>00217 {
<a name="l00218"></a>00218         <span class="keywordflow">if</span> (d.<a class="code" href="class_key_agreement_algorithm.html#5b0e622b88d0b8d319c23e4aefef414d">GetCryptoParameters</a>().<a class="code" href="class_crypto_material.html#439743c6b4e89ca8228a12fa1ea43ab1" title="check this object for errors">Validate</a>(GlobalRNG(), 3))
<a name="l00219"></a>00219                 cout &lt;&lt; <span class="stringliteral">"passed    authenticated key agreement domain parameters validation"</span> &lt;&lt; endl;
<a name="l00220"></a>00220         <span class="keywordflow">else</span>
<a name="l00221"></a>00221         {
<a name="l00222"></a>00222                 cout &lt;&lt; <span class="stringliteral">"FAILED    authenticated key agreement domain parameters invalid"</span> &lt;&lt; endl;
<a name="l00223"></a>00223                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00224"></a>00224         }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> spriv1(d.<a class="code" href="class_authenticated_key_agreement_domain.html#0a16421c7c21463f4b8a986b80f6c852" title="return length of static private keys in this domain">StaticPrivateKeyLength</a>()), spriv2(d.<a class="code" href="class_authenticated_key_agreement_domain.html#0a16421c7c21463f4b8a986b80f6c852" title="return length of static private keys in this domain">StaticPrivateKeyLength</a>());
<a name="l00227"></a>00227         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> epriv1(d.<a class="code" href="class_authenticated_key_agreement_domain.html#33c0c85b5ea7b2bd97d91676997b0e34" title="return length of ephemeral private keys in this domain">EphemeralPrivateKeyLength</a>()), epriv2(d.<a class="code" href="class_authenticated_key_agreement_domain.html#33c0c85b5ea7b2bd97d91676997b0e34" title="return length of ephemeral private keys in this domain">EphemeralPrivateKeyLength</a>());
<a name="l00228"></a>00228         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> spub1(d.<a class="code" href="class_authenticated_key_agreement_domain.html#744821a5d32333557adf304c09aeff6b" title="return length of static public keys in this domain">StaticPublicKeyLength</a>()), spub2(d.<a class="code" href="class_authenticated_key_agreement_domain.html#744821a5d32333557adf304c09aeff6b" title="return length of static public keys in this domain">StaticPublicKeyLength</a>());
<a name="l00229"></a>00229         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> epub1(d.<a class="code" href="class_authenticated_key_agreement_domain.html#50a15071c932e3bb134c6cb8f4c6d4f1" title="return length of ephemeral public keys in this domain">EphemeralPublicKeyLength</a>()), epub2(d.<a class="code" href="class_authenticated_key_agreement_domain.html#50a15071c932e3bb134c6cb8f4c6d4f1" title="return length of ephemeral public keys in this domain">EphemeralPublicKeyLength</a>());
<a name="l00230"></a>00230         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> val1(d.<a class="code" href="class_authenticated_key_agreement_domain.html#6d8b96f8a17e555bc9c6565d169a2418" title="return length of agreed value produced">AgreedValueLength</a>()), val2(d.<a class="code" href="class_authenticated_key_agreement_domain.html#6d8b96f8a17e555bc9c6565d169a2418" title="return length of agreed value produced">AgreedValueLength</a>());
<a name="l00231"></a>00231 
<a name="l00232"></a>00232         d.<a class="code" href="class_authenticated_key_agreement_domain.html#e2c306a6582c6e592ecb2c13abfd7c9f" title="generate private/public key pair">GenerateStaticKeyPair</a>(GlobalRNG(), spriv1, spub1);
<a name="l00233"></a>00233         d.<a class="code" href="class_authenticated_key_agreement_domain.html#e2c306a6582c6e592ecb2c13abfd7c9f" title="generate private/public key pair">GenerateStaticKeyPair</a>(GlobalRNG(), spriv2, spub2);
<a name="l00234"></a>00234         d.<a class="code" href="class_authenticated_key_agreement_domain.html#18f1fc5fa590be704d53759e44fba093" title="generate private/public key pair">GenerateEphemeralKeyPair</a>(GlobalRNG(), epriv1, epub1);
<a name="l00235"></a>00235         d.<a class="code" href="class_authenticated_key_agreement_domain.html#18f1fc5fa590be704d53759e44fba093" title="generate private/public key pair">GenerateEphemeralKeyPair</a>(GlobalRNG(), epriv2, epub2);
<a name="l00236"></a>00236 
<a name="l00237"></a>00237         memset(val1.begin(), 0x10, val1.size());
<a name="l00238"></a>00238         memset(val2.begin(), 0x11, val2.size());
<a name="l00239"></a>00239 
<a name="l00240"></a>00240         <span class="keywordflow">if</span> (!(d.<a class="code" href="class_authenticated_key_agreement_domain.html#c9808fb56eacee0c08a9bbd22fe2c98e" title="derive agreed value from your private keys and couterparty's public keys, return...">Agree</a>(val1, spriv1, epriv1, spub2, epub2) &amp;&amp; d.<a class="code" href="class_authenticated_key_agreement_domain.html#c9808fb56eacee0c08a9bbd22fe2c98e" title="derive agreed value from your private keys and couterparty's public keys, return...">Agree</a>(val2, spriv2, epriv2, spub1, epub1)))
<a name="l00241"></a>00241         {
<a name="l00242"></a>00242                 cout &lt;&lt; <span class="stringliteral">"FAILED    authenticated key agreement failed"</span> &lt;&lt; endl;
<a name="l00243"></a>00243                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00244"></a>00244         }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246         <span class="keywordflow">if</span> (memcmp(val1.begin(), val2.begin(), d.<a class="code" href="class_authenticated_key_agreement_domain.html#6d8b96f8a17e555bc9c6565d169a2418" title="return length of agreed value produced">AgreedValueLength</a>()))
<a name="l00247"></a>00247         {
<a name="l00248"></a>00248                 cout &lt;&lt; <span class="stringliteral">"FAILED    authenticated agreed values not equal"</span> &lt;&lt; endl;
<a name="l00249"></a>00249                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00250"></a>00250         }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252         cout &lt;&lt; <span class="stringliteral">"passed    authenticated key agreement"</span> &lt;&lt; endl;
<a name="l00253"></a>00253         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00254"></a>00254 }
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 <span class="keywordtype">bool</span> ValidateRSA()
<a name="l00257"></a>00257 {
<a name="l00258"></a>00258         cout &lt;&lt; <span class="stringliteral">"\nRSA validation suite running...\n\n"</span>;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260         byte out[100], outPlain[100];
<a name="l00261"></a>00261         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>, fail;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263         {
<a name="l00264"></a>00264                 <span class="keywordtype">char</span> *plain = <span class="stringliteral">"Everyone gets Friday off."</span>;
<a name="l00265"></a>00265                 byte *signature = (byte *)
<a name="l00266"></a>00266                         <span class="stringliteral">"\x05\xfa\x6a\x81\x2f\xc7\xdf\x8b\xf4\xf2\x54\x25\x09\xe0\x3e\x84"</span>
<a name="l00267"></a>00267                         <span class="stringliteral">"\x6e\x11\xb9\xc6\x20\xbe\x20\x09\xef\xb4\x40\xef\xbc\xc6\x69\x21"</span>
<a name="l00268"></a>00268                         <span class="stringliteral">"\x69\x94\xac\x04\xf3\x41\xb5\x7d\x05\x20\x2d\x42\x8f\xb2\xa2\x7b"</span>
<a name="l00269"></a>00269                         <span class="stringliteral">"\x5c\x77\xdf\xd9\xb1\x5b\xfc\x3d\x55\x93\x53\x50\x34\x10\xc1\xe1"</span>;
<a name="l00270"></a>00270 
<a name="l00271"></a>00271                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> keys(<span class="stringliteral">"rsa512a.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00272"></a>00272                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">Weak::RSASSA_PKCS1v15_MD2_Signer</a> rsaPriv(keys);
<a name="l00273"></a>00273                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">Weak::RSASSA_PKCS1v15_MD2_Verifier</a> rsaPub(rsaPriv);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275                 <span class="keywordtype">size_t</span> signatureLength = rsaPriv.SignMessage(GlobalRNG(), (byte *)plain, strlen(plain), out);
<a name="l00276"></a>00276                 fail = memcmp(signature, out, 64) != 0;
<a name="l00277"></a>00277                 pass = pass &amp;&amp; !fail;
<a name="l00278"></a>00278 
<a name="l00279"></a>00279                 cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00280"></a>00280                 cout &lt;&lt; <span class="stringliteral">"signature check against test vector\n"</span>;
<a name="l00281"></a>00281 
<a name="l00282"></a>00282                 fail = !rsaPub.VerifyMessage((byte *)plain, strlen(plain), out, signatureLength);
<a name="l00283"></a>00283                 pass = pass &amp;&amp; !fail;
<a name="l00284"></a>00284 
<a name="l00285"></a>00285                 cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00286"></a>00286                 cout &lt;&lt; <span class="stringliteral">"verification check against test vector\n"</span>;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288                 out[10]++;
<a name="l00289"></a>00289                 fail = rsaPub.VerifyMessage((byte *)plain, strlen(plain), out, signatureLength);
<a name="l00290"></a>00290                 pass = pass &amp;&amp; !fail;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292                 cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00293"></a>00293                 cout &lt;&lt; <span class="stringliteral">"invalid signature verification\n"</span>;
<a name="l00294"></a>00294         }
<a name="l00295"></a>00295         {
<a name="l00296"></a>00296                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> keys(<span class="stringliteral">"rsa1024.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00297"></a>00297                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">RSAES_PKCS1v15_Decryptor</a> rsaPriv(keys);
<a name="l00298"></a>00298                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">RSAES_PKCS1v15_Encryptor</a> rsaPub(rsaPriv);
<a name="l00299"></a>00299 
<a name="l00300"></a>00300                 pass = CryptoSystemValidate(rsaPriv, rsaPub) &amp;&amp; pass;
<a name="l00301"></a>00301         }
<a name="l00302"></a>00302         {
<a name="l00303"></a>00303                 byte *plain = (byte *)
<a name="l00304"></a>00304                         <span class="stringliteral">"\x54\x85\x9b\x34\x2c\x49\xea\x2a"</span>;
<a name="l00305"></a>00305                 byte *encrypted = (byte *)
<a name="l00306"></a>00306                         <span class="stringliteral">"\x14\xbd\xdd\x28\xc9\x83\x35\x19\x23\x80\xe8\xe5\x49\xb1\x58\x2a"</span>
<a name="l00307"></a>00307                         <span class="stringliteral">"\x8b\x40\xb4\x48\x6d\x03\xa6\xa5\x31\x1f\x1f\xd5\xf0\xa1\x80\xe4"</span>
<a name="l00308"></a>00308                         <span class="stringliteral">"\x17\x53\x03\x29\xa9\x34\x90\x74\xb1\x52\x13\x54\x29\x08\x24\x52"</span>
<a name="l00309"></a>00309                         <span class="stringliteral">"\x62\x51"</span>;
<a name="l00310"></a>00310                 byte *oaepSeed = (byte *)
<a name="l00311"></a>00311                         <span class="stringliteral">"\xaa\xfd\x12\xf6\x59\xca\xe6\x34\x89\xb4\x79\xe5\x07\x6d\xde\xc2"</span>
<a name="l00312"></a>00312                         <span class="stringliteral">"\xf0\x6c\xb5\x8f"</span>;
<a name="l00313"></a>00313                 <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> bq;
<a name="l00314"></a>00314                 bq.<a class="code" href="class_buffered_transformation.html#e70658b0d271f8e114ac6c3cc9774ede" title="input a byte for processing">Put</a>(oaepSeed, 20);
<a name="l00315"></a>00315                 <a class="code" href="class_fixed_r_n_g.html">FixedRNG</a> rng(bq);
<a name="l00316"></a>00316 
<a name="l00317"></a>00317                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> privFile(<span class="stringliteral">"rsa400pv.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00318"></a>00318                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> pubFile(<span class="stringliteral">"rsa400pb.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00319"></a>00319                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">RSAES_OAEP_SHA_Decryptor</a> rsaPriv;
<a name="l00320"></a>00320                 rsaPriv.AccessKey().BERDecodePrivateKey(privFile, <span class="keyword">false</span>, 0);
<a name="l00321"></a>00321                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">RSAES_OAEP_SHA_Encryptor</a> rsaPub(pubFile);
<a name="l00322"></a>00322 
<a name="l00323"></a>00323                 memset(out, 0, 50);
<a name="l00324"></a>00324                 memset(outPlain, 0, 8);
<a name="l00325"></a>00325                 rsaPub.Encrypt(rng, plain, 8, out);
<a name="l00326"></a>00326                 <a class="code" href="struct_decoding_result.html" title="used to return decoding results">DecodingResult</a> result = rsaPriv.FixedLengthDecrypt(GlobalRNG(), encrypted, outPlain);
<a name="l00327"></a>00327                 fail = !result.<a class="code" href="struct_decoding_result.html#b88062318cd0e68b3061db351d3ba34d">isValidCoding</a> || (result.<a class="code" href="struct_decoding_result.html#f4496c82e5764175a27e36629e1cded7">messageLength</a>!=8) || memcmp(out, encrypted, 50) || memcmp(plain, outPlain, 8);
<a name="l00328"></a>00328                 pass = pass &amp;&amp; !fail;
<a name="l00329"></a>00329 
<a name="l00330"></a>00330                 cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00331"></a>00331                 cout &lt;&lt; <span class="stringliteral">"PKCS 2.0 encryption and decryption\n"</span>;
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334         <span class="keywordflow">return</span> pass;
<a name="l00335"></a>00335 }
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="keywordtype">bool</span> ValidateDH()
<a name="l00338"></a>00338 {
<a name="l00339"></a>00339         cout &lt;&lt; <span class="stringliteral">"\nDH validation suite running...\n\n"</span>;
<a name="l00340"></a>00340 
<a name="l00341"></a>00341         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">"dh1024.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00342"></a>00342         <a class="code" href="class_d_h___domain.html" title=",">DH</a> dh(f);
<a name="l00343"></a>00343         <span class="keywordflow">return</span> SimpleKeyAgreementValidate(dh);
<a name="l00344"></a>00344 }
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 <span class="keywordtype">bool</span> ValidateMQV()
<a name="l00347"></a>00347 {
<a name="l00348"></a>00348         cout &lt;&lt; <span class="stringliteral">"\nMQV validation suite running...\n\n"</span>;
<a name="l00349"></a>00349 
<a name="l00350"></a>00350         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">"mqv1024.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00351"></a>00351         <a class="code" href="class_m_q_v___domain.html" title="_">MQV</a> mqv(f);
<a name="l00352"></a>00352         <span class="keywordflow">return</span> AuthenticatedKeyAgreementValidate(mqv);
<a name="l00353"></a>00353 }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 <span class="keywordtype">bool</span> ValidateLUC_DH()
<a name="l00356"></a>00356 {
<a name="l00357"></a>00357         cout &lt;&lt; <span class="stringliteral">"\nLUC-DH validation suite running...\n\n"</span>;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">"lucd512.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00360"></a>00360         <a class="code" href="class_d_h___domain.html" title=",">LUC_DH</a> dh(f);
<a name="l00361"></a>00361         <span class="keywordflow">return</span> SimpleKeyAgreementValidate(dh);
<a name="l00362"></a>00362 }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 <span class="keywordtype">bool</span> ValidateXTR_DH()
<a name="l00365"></a>00365 {
<a name="l00366"></a>00366         cout &lt;&lt; <span class="stringliteral">"\nXTR-DH validation suite running...\n\n"</span>;
<a name="l00367"></a>00367 
<a name="l00368"></a>00368         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">"xtrdh171.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00369"></a>00369         <a class="code" href="class_x_t_r___d_h.html" title="XTR-DH with key validation.">XTR_DH</a> dh(f);
<a name="l00370"></a>00370         <span class="keywordflow">return</span> SimpleKeyAgreementValidate(dh);
<a name="l00371"></a>00371 }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 <span class="keywordtype">bool</span> ValidateElGamal()
<a name="l00374"></a>00374 {
<a name="l00375"></a>00375         cout &lt;&lt; <span class="stringliteral">"\nElGamal validation suite running...\n\n"</span>;
<a name="l00376"></a>00376         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>;
<a name="l00377"></a>00377         {
<a name="l00378"></a>00378                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> fc(<span class="stringliteral">"elgc1024.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00379"></a>00379                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ElGamalDecryptor</a> privC(fc);
<a name="l00380"></a>00380                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ElGamalEncryptor</a> pubC(privC);
<a name="l00381"></a>00381                 privC.AccessKey().Precompute();
<a name="l00382"></a>00382                 <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> queue;
<a name="l00383"></a>00383                 privC.AccessKey().SavePrecomputation(queue);
<a name="l00384"></a>00384                 privC.AccessKey().LoadPrecomputation(queue);
<a name="l00385"></a>00385 
<a name="l00386"></a>00386                 pass = CryptoSystemValidate(privC, pubC) &amp;&amp; pass;
<a name="l00387"></a>00387         }
<a name="l00388"></a>00388         <span class="keywordflow">return</span> pass;
<a name="l00389"></a>00389 }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="keywordtype">bool</span> ValidateDLIES()
<a name="l00392"></a>00392 {
<a name="l00393"></a>00393         cout &lt;&lt; <span class="stringliteral">"\nDLIES validation suite running...\n\n"</span>;
<a name="l00394"></a>00394         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>;
<a name="l00395"></a>00395         {
<a name="l00396"></a>00396                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> fc(<span class="stringliteral">"dlie1024.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00397"></a>00397                 <a class="code" href="struct_d_l_i_e_s.html" title="Discrete Log Integrated Encryption Scheme, AKA DLIES.">DLIES&lt;&gt;::Decryptor</a> privC(fc);
<a name="l00398"></a>00398                 <a class="code" href="struct_d_l_i_e_s.html" title="Discrete Log Integrated Encryption Scheme, AKA DLIES.">DLIES&lt;&gt;::Encryptor</a> pubC(privC);
<a name="l00399"></a>00399                 pass = CryptoSystemValidate(privC, pubC) &amp;&amp; pass;
<a name="l00400"></a>00400         }
<a name="l00401"></a>00401         {
<a name="l00402"></a>00402                 cout &lt;&lt; <span class="stringliteral">"Generating new encryption key..."</span> &lt;&lt; endl;
<a name="l00403"></a>00403                 <a class="code" href="struct_d_l_i_e_s.html" title="Discrete Log Integrated Encryption Scheme, AKA DLIES.">DLIES&lt;&gt;::GroupParameters</a> gp;
<a name="l00404"></a>00404                 gp.GenerateRandomWithKeySize(GlobalRNG(), 128);
<a name="l00405"></a>00405                 <a class="code" href="struct_d_l_i_e_s.html" title="Discrete Log Integrated Encryption Scheme, AKA DLIES.">DLIES&lt;&gt;::Decryptor</a> decryptor;
<a name="l00406"></a>00406                 decryptor.AccessKey().GenerateRandom(GlobalRNG(), gp);
<a name="l00407"></a>00407                 <a class="code" href="struct_d_l_i_e_s.html" title="Discrete Log Integrated Encryption Scheme, AKA DLIES.">DLIES&lt;&gt;::Encryptor</a> encryptor(decryptor);
<a name="l00408"></a>00408 
<a name="l00409"></a>00409                 pass = CryptoSystemValidate(decryptor, encryptor) &amp;&amp; pass;
<a name="l00410"></a>00410         }
<a name="l00411"></a>00411         <span class="keywordflow">return</span> pass;
<a name="l00412"></a>00412 }
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="keywordtype">bool</span> ValidateNR()
<a name="l00415"></a>00415 {
<a name="l00416"></a>00416         cout &lt;&lt; <span class="stringliteral">"\nNR validation suite running...\n\n"</span>;
<a name="l00417"></a>00417         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>;
<a name="l00418"></a>00418         {
<a name="l00419"></a>00419                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">"nr2048.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00420"></a>00420                 <a class="code" href="struct_n_r.html" title="NR">NR&lt;SHA&gt;::Signer</a> privS(f);
<a name="l00421"></a>00421                 privS.AccessKey().Precompute();
<a name="l00422"></a>00422                 <a class="code" href="struct_n_r.html" title="NR">NR&lt;SHA&gt;::Verifier</a> pubS(privS);
<a name="l00423"></a>00423 
<a name="l00424"></a>00424                 pass = SignatureValidate(privS, pubS) &amp;&amp; pass;
<a name="l00425"></a>00425         }
<a name="l00426"></a>00426         {
<a name="l00427"></a>00427                 cout &lt;&lt; <span class="stringliteral">"Generating new signature key..."</span> &lt;&lt; endl;
<a name="l00428"></a>00428                 <a class="code" href="struct_n_r.html" title="NR">NR&lt;SHA&gt;::Signer</a> privS(GlobalRNG(), 256);
<a name="l00429"></a>00429                 <a class="code" href="struct_n_r.html" title="NR">NR&lt;SHA&gt;::Verifier</a> pubS(privS);
<a name="l00430"></a>00430 
<a name="l00431"></a>00431                 pass = SignatureValidate(privS, pubS) &amp;&amp; pass;
<a name="l00432"></a>00432         }
<a name="l00433"></a>00433         <span class="keywordflow">return</span> pass;
<a name="l00434"></a>00434 }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 <span class="keywordtype">bool</span> ValidateDSA(<span class="keywordtype">bool</span> thorough)
<a name="l00437"></a>00437 {
<a name="l00438"></a>00438         cout &lt;&lt; <span class="stringliteral">"\nDSA validation suite running...\n\n"</span>;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>, fail;
<a name="l00441"></a>00441         {
<a name="l00442"></a>00442         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> fs(<span class="stringliteral">"dsa512.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00443"></a>00443         <a class="code" href="struct_g_d_s_a.html" title="DSA-1363">GDSA&lt;SHA&gt;::Signer</a> priv(fs);
<a name="l00444"></a>00444         priv.AccessKey().Precompute(16);
<a name="l00445"></a>00445         <a class="code" href="struct_g_d_s_a.html" title="DSA-1363">GDSA&lt;SHA&gt;::Verifier</a> pub(priv);
<a name="l00446"></a>00446 
<a name="l00447"></a>00447         byte seed[]={0xd5, 0x01, 0x4e, 0x4b, 0x60, 0xef, 0x2b, 0xa8, 0xb6, 0x21, 
<a name="l00448"></a>00448                                  0x1b, 0x40, 0x62, 0xba, 0x32, 0x24, 0xe0, 0x42, 0x7d, 0xd3};
<a name="l00449"></a>00449         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> k(<span class="stringliteral">"358dad57 1462710f 50e254cf 1a376b2b deaadfbfh"</span>);
<a name="l00450"></a>00450         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> h(<span class="stringliteral">"a9993e36 4706816a ba3e2571 7850c26c 9cd0d89dh"</span>);
<a name="l00451"></a>00451         byte sig[]={0x8b, 0xac, 0x1a, 0xb6, 0x64, 0x10, 0x43, 0x5c, 0xb7, 0x18,
<a name="l00452"></a>00452                                 0x1f, 0x95, 0xb1, 0x6a, 0xb9, 0x7c, 0x92, 0xb3, 0x41, 0xc0, 
<a name="l00453"></a>00453                                 0x41, 0xe2, 0x34, 0x5f, 0x1f, 0x56, 0xdf, 0x24, 0x58, 0xf4, 
<a name="l00454"></a>00454                                 0x26, 0xd1, 0x55, 0xb4, 0xba, 0x2d, 0xb6, 0xdc, 0xd8, 0xc8};
<a name="l00455"></a>00455         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> r(sig, 20);
<a name="l00456"></a>00456         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> s(sig+20, 20);
<a name="l00457"></a>00457 
<a name="l00458"></a>00458         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> pGen, qGen, rOut, sOut;
<a name="l00459"></a>00459         <span class="keywordtype">int</span> c;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461         fail = !<a class="code" href="struct_d_s_a.html#48eab0da4234a2d20f3ef7250fbad5f5" title="Generate DSA primes according to NIST standard.">DSA::GeneratePrimes</a>(seed, 160, c, pGen, 512, qGen);
<a name="l00462"></a>00462         fail = fail || (pGen != pub.GetKey().GetGroupParameters().GetModulus()) || (qGen != pub.GetKey().GetGroupParameters().GetSubgroupOrder());
<a name="l00463"></a>00463         pass = pass &amp;&amp; !fail;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00466"></a>00466         cout &lt;&lt; <span class="stringliteral">"prime generation test\n"</span>;
<a name="l00467"></a>00467 
<a name="l00468"></a>00468         priv.RawSign(k, h, rOut, sOut);
<a name="l00469"></a>00469         fail = (rOut != r) || (sOut != s);
<a name="l00470"></a>00470         pass = pass &amp;&amp; !fail;
<a name="l00471"></a>00471 
<a name="l00472"></a>00472         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00473"></a>00473         cout &lt;&lt; <span class="stringliteral">"signature check against test vector\n"</span>;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475         fail = !pub.VerifyMessage((byte *)<span class="stringliteral">"abc"</span>, 3, sig, <span class="keyword">sizeof</span>(sig));
<a name="l00476"></a>00476         pass = pass &amp;&amp; !fail;
<a name="l00477"></a>00477 
<a name="l00478"></a>00478         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00479"></a>00479         cout &lt;&lt; <span class="stringliteral">"verification check against test vector\n"</span>;
<a name="l00480"></a>00480 
<a name="l00481"></a>00481         fail = pub.VerifyMessage((byte *)<span class="stringliteral">"xyz"</span>, 3, sig, <span class="keyword">sizeof</span>(sig));
<a name="l00482"></a>00482         pass = pass &amp;&amp; !fail;
<a name="l00483"></a>00483         }
<a name="l00484"></a>00484         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> fs1(<span class="stringliteral">"dsa1024.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00485"></a>00485         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">DSA::Signer</a> priv(fs1);
<a name="l00486"></a>00486         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">DSA::Verifier</a> pub(priv);
<a name="l00487"></a>00487         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> fs2(<span class="stringliteral">"dsa1024b.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00488"></a>00488         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">DSA::Verifier</a> pub1(fs2);
<a name="l00489"></a>00489         assert(pub.GetKey() == pub1.GetKey());
<a name="l00490"></a>00490         pass = SignatureValidate(priv, pub, thorough) &amp;&amp; pass;
<a name="l00491"></a>00491         <span class="keywordflow">return</span> pass;
<a name="l00492"></a>00492 }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 <span class="keywordtype">bool</span> ValidateLUC()
<a name="l00495"></a>00495 {
<a name="l00496"></a>00496         cout &lt;&lt; <span class="stringliteral">"\nLUC validation suite running...\n\n"</span>;
<a name="l00497"></a>00497         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499         {
<a name="l00500"></a>00500                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">"luc1024.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00501"></a>00501                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">LUCSSA_PKCS1v15_SHA_Signer</a> priv(f);
<a name="l00502"></a>00502                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">LUCSSA_PKCS1v15_SHA_Verifier</a> pub(priv);
<a name="l00503"></a>00503                 pass = SignatureValidate(priv, pub) &amp;&amp; pass;
<a name="l00504"></a>00504         }
<a name="l00505"></a>00505         {
<a name="l00506"></a>00506                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">LUCES_OAEP_SHA_Decryptor</a> priv(GlobalRNG(), 512);
<a name="l00507"></a>00507                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">LUCES_OAEP_SHA_Encryptor</a> pub(priv);
<a name="l00508"></a>00508                 pass = CryptoSystemValidate(priv, pub) &amp;&amp; pass;
<a name="l00509"></a>00509         }
<a name="l00510"></a>00510         <span class="keywordflow">return</span> pass;
<a name="l00511"></a>00511 }
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="keywordtype">bool</span> ValidateLUC_DL()
<a name="l00514"></a>00514 {
<a name="l00515"></a>00515         cout &lt;&lt; <span class="stringliteral">"\nLUC-HMP validation suite running...\n\n"</span>;
<a name="l00516"></a>00516 
<a name="l00517"></a>00517         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">"lucs512.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00518"></a>00518         <a class="code" href="struct_l_u_c___h_m_p.html" title="LUC-HMP, based on "Digital signature schemes based on Lucas functions" by Patrick...">LUC_HMP&lt;SHA&gt;::Signer</a> privS(f);
<a name="l00519"></a>00519         <a class="code" href="struct_l_u_c___h_m_p.html" title="LUC-HMP, based on "Digital signature schemes based on Lucas functions" by Patrick...">LUC_HMP&lt;SHA&gt;::Verifier</a> pubS(privS);
<a name="l00520"></a>00520         <span class="keywordtype">bool</span> pass = SignatureValidate(privS, pubS);
<a name="l00521"></a>00521 
<a name="l00522"></a>00522         cout &lt;&lt; <span class="stringliteral">"\nLUC-IES validation suite running...\n\n"</span>;
<a name="l00523"></a>00523 
<a name="l00524"></a>00524         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> fc(<span class="stringliteral">"lucc512.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00525"></a>00525         <a class="code" href="struct_l_u_c___i_e_s.html" title="LUC-IES.">LUC_IES&lt;&gt;::Decryptor</a> privC(fc);
<a name="l00526"></a>00526         <a class="code" href="struct_l_u_c___i_e_s.html" title="LUC-IES.">LUC_IES&lt;&gt;::Encryptor</a> pubC(privC);
<a name="l00527"></a>00527         pass = CryptoSystemValidate(privC, pubC) &amp;&amp; pass;
<a name="l00528"></a>00528 
<a name="l00529"></a>00529         <span class="keywordflow">return</span> pass;
<a name="l00530"></a>00530 }
<a name="l00531"></a>00531 
<a name="l00532"></a>00532 <span class="keywordtype">bool</span> ValidateRabin()
<a name="l00533"></a>00533 {
<a name="l00534"></a>00534         cout &lt;&lt; <span class="stringliteral">"\nRabin validation suite running...\n\n"</span>;
<a name="l00535"></a>00535         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>;
<a name="l00536"></a>00536 
<a name="l00537"></a>00537         {
<a name="l00538"></a>00538                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">"rabi1024.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00539"></a>00539                 <a class="code" href="struct_rabin_s_s.html" title="Rabin signature.">RabinSS&lt;PSSR, SHA&gt;::Signer</a> priv(f);
<a name="l00540"></a>00540                 <a class="code" href="struct_rabin_s_s.html" title="Rabin signature.">RabinSS&lt;PSSR, SHA&gt;::Verifier</a> pub(priv);
<a name="l00541"></a>00541                 pass = SignatureValidate(priv, pub) &amp;&amp; pass;
<a name="l00542"></a>00542         }
<a name="l00543"></a>00543         {
<a name="l00544"></a>00544                 <a class="code" href="struct_rabin_e_s.html" title="Rabin encryption.">RabinES&lt;OAEP&lt;SHA&gt;</a> &gt;::Decryptor priv(GlobalRNG(), 512);
<a name="l00545"></a>00545                 <a class="code" href="struct_rabin_e_s.html" title="Rabin encryption.">RabinES&lt;OAEP&lt;SHA&gt;</a> &gt;::Encryptor pub(priv);
<a name="l00546"></a>00546                 pass = CryptoSystemValidate(priv, pub) &amp;&amp; pass;
<a name="l00547"></a>00547         }
<a name="l00548"></a>00548         <span class="keywordflow">return</span> pass;
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="keywordtype">bool</span> ValidateRW()
<a name="l00552"></a>00552 {
<a name="l00553"></a>00553         cout &lt;&lt; <span class="stringliteral">"\nRW validation suite running...\n\n"</span>;
<a name="l00554"></a>00554 
<a name="l00555"></a>00555         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">"rw1024.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00556"></a>00556         <a class="code" href="struct_r_w_s_s.html" title="RWSS.">RWSS&lt;PSSR, SHA&gt;::Signer</a> priv(f);
<a name="l00557"></a>00557         <a class="code" href="struct_r_w_s_s.html" title="RWSS.">RWSS&lt;PSSR, SHA&gt;::Verifier</a> pub(priv);
<a name="l00558"></a>00558 
<a name="l00559"></a>00559         <span class="keywordflow">return</span> SignatureValidate(priv, pub);
<a name="l00560"></a>00560 }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 <span class="comment">/*</span>
<a name="l00563"></a>00563 <span class="comment">bool ValidateBlumGoldwasser()</span>
<a name="l00564"></a>00564 <span class="comment">{</span>
<a name="l00565"></a>00565 <span class="comment">        cout &lt;&lt; "\nBlumGoldwasser validation suite running...\n\n";</span>
<a name="l00566"></a>00566 <span class="comment"></span>
<a name="l00567"></a>00567 <span class="comment">        FileSource f("blum512.dat", true, new HexDecoder);</span>
<a name="l00568"></a>00568 <span class="comment">        BlumGoldwasserPrivateKey priv(f);</span>
<a name="l00569"></a>00569 <span class="comment">        BlumGoldwasserPublicKey pub(priv);</span>
<a name="l00570"></a>00570 <span class="comment"></span>
<a name="l00571"></a>00571 <span class="comment">        return CryptoSystemValidate(priv, pub);</span>
<a name="l00572"></a>00572 <span class="comment">}</span>
<a name="l00573"></a>00573 <span class="comment">*/</span>
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 <span class="keywordtype">bool</span> ValidateECP()
<a name="l00576"></a>00576 {
<a name="l00577"></a>00577         cout &lt;&lt; <span class="stringliteral">"\nECP validation suite running...\n\n"</span>;
<a name="l00578"></a>00578 
<a name="l00579"></a>00579         <a class="code" href="struct_e_c_i_e_s.html" title="Elliptic Curve Integrated Encryption Scheme, AKA ECIES.">ECIES&lt;ECP&gt;::Decryptor</a> cpriv(GlobalRNG(), ASN1::secp192r1());
<a name="l00580"></a>00580         <a class="code" href="struct_e_c_i_e_s.html" title="Elliptic Curve Integrated Encryption Scheme, AKA ECIES.">ECIES&lt;ECP&gt;::Encryptor</a> cpub(cpriv);
<a name="l00581"></a>00581         <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> bq;
<a name="l00582"></a>00582         cpriv.GetKey().DEREncode(bq);
<a name="l00583"></a>00583         cpub.AccessKey().AccessGroupParameters().SetEncodeAsOID(<span class="keyword">true</span>);
<a name="l00584"></a>00584         cpub.GetKey().DEREncode(bq);
<a name="l00585"></a>00585         <a class="code" href="struct_e_c_d_s_a.html" title="ECDSA">ECDSA&lt;ECP, SHA&gt;::Signer</a> spriv(bq);
<a name="l00586"></a>00586         <a class="code" href="struct_e_c_d_s_a.html" title="ECDSA">ECDSA&lt;ECP, SHA&gt;::Verifier</a> spub(bq);
<a name="l00587"></a>00587         <a class="code" href="struct_e_c_d_h.html" title="Elliptic Curve Diffie-Hellman, AKA ECDH.">ECDH&lt;ECP&gt;::Domain</a> ecdhc(ASN1::secp192r1());
<a name="l00588"></a>00588         <a class="code" href="struct_e_c_m_q_v.html" title="Elliptic Curve Menezes-Qu-Vanstone, AKA ECMQV.">ECMQV&lt;ECP&gt;::Domain</a> ecmqvc(ASN1::secp192r1());
<a name="l00589"></a>00589 
<a name="l00590"></a>00590         spriv.AccessKey().Precompute();
<a name="l00591"></a>00591         <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> queue;
<a name="l00592"></a>00592         spriv.AccessKey().SavePrecomputation(queue);
<a name="l00593"></a>00593         spriv.AccessKey().LoadPrecomputation(queue);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595         <span class="keywordtype">bool</span> pass = SignatureValidate(spriv, spub);
<a name="l00596"></a>00596         cpub.AccessKey().Precompute();
<a name="l00597"></a>00597         cpriv.AccessKey().Precompute();
<a name="l00598"></a>00598         pass = CryptoSystemValidate(cpriv, cpub) &amp;&amp; pass;
<a name="l00599"></a>00599         pass = SimpleKeyAgreementValidate(ecdhc) &amp;&amp; pass;
<a name="l00600"></a>00600         pass = AuthenticatedKeyAgreementValidate(ecmqvc) &amp;&amp; pass;
<a name="l00601"></a>00601 
<a name="l00602"></a>00602         cout &lt;&lt; <span class="stringliteral">"Turning on point compression..."</span> &lt;&lt; endl;
<a name="l00603"></a>00603         cpriv.AccessKey().AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00604"></a>00604         cpub.AccessKey().AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00605"></a>00605         ecdhc.AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00606"></a>00606         ecmqvc.AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00607"></a>00607         pass = CryptoSystemValidate(cpriv, cpub) &amp;&amp; pass;
<a name="l00608"></a>00608         pass = SimpleKeyAgreementValidate(ecdhc) &amp;&amp; pass;
<a name="l00609"></a>00609         pass = AuthenticatedKeyAgreementValidate(ecmqvc) &amp;&amp; pass;
<a name="l00610"></a>00610 
<a name="l00611"></a>00611         cout &lt;&lt; <span class="stringliteral">"Testing SEC 2 recommended curves..."</span> &lt;&lt; endl;
<a name="l00612"></a>00612         <a class="code" href="class_o_i_d.html" title="Object Identifier.">OID</a> oid;
<a name="l00613"></a>00613         <span class="keywordflow">while</span> (!(oid = <a class="code" href="class_d_l___group_parameters___e_c.html" title="Elliptic Curve Parameters.">DL_GroupParameters_EC&lt;ECP&gt;::GetNextRecommendedParametersOID</a>(oid)).m_values.empty())
<a name="l00614"></a>00614         {
<a name="l00615"></a>00615                 <a class="code" href="class_d_l___group_parameters___e_c.html" title="Elliptic Curve Parameters.">DL_GroupParameters_EC&lt;ECP&gt;</a> params(oid);
<a name="l00616"></a>00616                 <span class="keywordtype">bool</span> fail = !params.Validate(GlobalRNG(), 2);
<a name="l00617"></a>00617                 cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED"</span> : <span class="stringliteral">"passed"</span>) &lt;&lt; <span class="stringliteral">"    "</span> &lt;&lt; dec &lt;&lt; params.GetCurve().GetField().MaxElementBitLength() &lt;&lt; <span class="stringliteral">" bits"</span> &lt;&lt; endl;
<a name="l00618"></a>00618                 pass = pass &amp;&amp; !fail;
<a name="l00619"></a>00619         }
<a name="l00620"></a>00620 
<a name="l00621"></a>00621         <span class="keywordflow">return</span> pass;
<a name="l00622"></a>00622 }
<a name="l00623"></a>00623 
<a name="l00624"></a>00624 <span class="keywordtype">bool</span> ValidateEC2N()
<a name="l00625"></a>00625 {
<a name="l00626"></a>00626         cout &lt;&lt; <span class="stringliteral">"\nEC2N validation suite running...\n\n"</span>;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628         <a class="code" href="struct_e_c_i_e_s.html" title="Elliptic Curve Integrated Encryption Scheme, AKA ECIES.">ECIES&lt;EC2N&gt;::Decryptor</a> cpriv(GlobalRNG(), ASN1::sect193r1());
<a name="l00629"></a>00629         <a class="code" href="struct_e_c_i_e_s.html" title="Elliptic Curve Integrated Encryption Scheme, AKA ECIES.">ECIES&lt;EC2N&gt;::Encryptor</a> cpub(cpriv);
<a name="l00630"></a>00630         <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> bq;
<a name="l00631"></a>00631         cpriv.DEREncode(bq);
<a name="l00632"></a>00632         cpub.AccessKey().AccessGroupParameters().SetEncodeAsOID(<span class="keyword">true</span>);
<a name="l00633"></a>00633         cpub.DEREncode(bq);
<a name="l00634"></a>00634         <a class="code" href="struct_e_c_d_s_a.html" title="ECDSA">ECDSA&lt;EC2N, SHA&gt;::Signer</a> spriv(bq);
<a name="l00635"></a>00635         <a class="code" href="struct_e_c_d_s_a.html" title="ECDSA">ECDSA&lt;EC2N, SHA&gt;::Verifier</a> spub(bq);
<a name="l00636"></a>00636         <a class="code" href="struct_e_c_d_h.html" title="Elliptic Curve Diffie-Hellman, AKA ECDH.">ECDH&lt;EC2N&gt;::Domain</a> ecdhc(ASN1::sect193r1());
<a name="l00637"></a>00637         <a class="code" href="struct_e_c_m_q_v.html" title="Elliptic Curve Menezes-Qu-Vanstone, AKA ECMQV.">ECMQV&lt;EC2N&gt;::Domain</a> ecmqvc(ASN1::sect193r1());
<a name="l00638"></a>00638 
<a name="l00639"></a>00639         spriv.AccessKey().Precompute();
<a name="l00640"></a>00640         <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> queue;
<a name="l00641"></a>00641         spriv.AccessKey().SavePrecomputation(queue);
<a name="l00642"></a>00642         spriv.AccessKey().LoadPrecomputation(queue);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644         <span class="keywordtype">bool</span> pass = SignatureValidate(spriv, spub);
<a name="l00645"></a>00645         pass = CryptoSystemValidate(cpriv, cpub) &amp;&amp; pass;
<a name="l00646"></a>00646         pass = SimpleKeyAgreementValidate(ecdhc) &amp;&amp; pass;
<a name="l00647"></a>00647         pass = AuthenticatedKeyAgreementValidate(ecmqvc) &amp;&amp; pass;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649         cout &lt;&lt; <span class="stringliteral">"Turning on point compression..."</span> &lt;&lt; endl;
<a name="l00650"></a>00650         cpriv.AccessKey().AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00651"></a>00651         cpub.AccessKey().AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00652"></a>00652         ecdhc.AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00653"></a>00653         ecmqvc.AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00654"></a>00654         pass = CryptoSystemValidate(cpriv, cpub) &amp;&amp; pass;
<a name="l00655"></a>00655         pass = SimpleKeyAgreementValidate(ecdhc) &amp;&amp; pass;
<a name="l00656"></a>00656         pass = AuthenticatedKeyAgreementValidate(ecmqvc) &amp;&amp; pass;
<a name="l00657"></a>00657 
<a name="l00658"></a>00658 <span class="preprocessor">#if 0   // TODO: turn this back on when I make EC2N faster for pentanomial basis</span>
<a name="l00659"></a>00659 <span class="preprocessor"></span>        cout &lt;&lt; <span class="stringliteral">"Testing SEC 2 recommended curves..."</span> &lt;&lt; endl;
<a name="l00660"></a>00660         <a class="code" href="class_o_i_d.html" title="Object Identifier.">OID</a> oid;
<a name="l00661"></a>00661         <span class="keywordflow">while</span> (!(oid = ECParameters&lt;EC2N&gt;::GetNextRecommendedParametersOID(oid)).m_values.empty())
<a name="l00662"></a>00662         {
<a name="l00663"></a>00663                 ECParameters&lt;EC2N&gt; params(oid);
<a name="l00664"></a>00664                 <span class="keywordtype">bool</span> fail = !params.ValidateParameters(GlobalRNG());
<a name="l00665"></a>00665                 cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED"</span> : <span class="stringliteral">"passed"</span>) &lt;&lt; <span class="stringliteral">"    "</span> &lt;&lt; params.<a class="code" href="class_d_l___group_parameters___e_c.html#1878b13f22da409ea562581823b6b5d2">GetCurve</a>().GetField().MaxElementBitLength() &lt;&lt; <span class="stringliteral">" bits"</span> &lt;&lt; endl;
<a name="l00666"></a>00666                 pass = pass &amp;&amp; !fail;
<a name="l00667"></a>00667         }
<a name="l00668"></a>00668 <span class="preprocessor">#endif</span>
<a name="l00669"></a>00669 <span class="preprocessor"></span>
<a name="l00670"></a>00670         <span class="keywordflow">return</span> pass;
<a name="l00671"></a>00671 }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 <span class="keywordtype">bool</span> ValidateECDSA()
<a name="l00674"></a>00674 {
<a name="l00675"></a>00675         cout &lt;&lt; <span class="stringliteral">"\nECDSA validation suite running...\n\n"</span>;
<a name="l00676"></a>00676 
<a name="l00677"></a>00677         <span class="comment">// from Sample Test Vectors for P1363</span>
<a name="l00678"></a>00678         <a class="code" href="class_g_f2_n_t.html" title="GF(2^n) with Trinomial Basis.">GF2NT</a> gf2n(191, 9, 0);
<a name="l00679"></a>00679         byte a[]=<span class="stringliteral">"\x28\x66\x53\x7B\x67\x67\x52\x63\x6A\x68\xF5\x65\x54\xE1\x26\x40\x27\x6B\x64\x9E\xF7\x52\x62\x67"</span>;
<a name="l00680"></a>00680         byte b[]=<span class="stringliteral">"\x2E\x45\xEF\x57\x1F\x00\x78\x6F\x67\xB0\x08\x1B\x94\x95\xA3\xD9\x54\x62\xF5\xDE\x0A\xA1\x85\xEC"</span>;
<a name="l00681"></a>00681         <a class="code" href="class_e_c2_n.html" title="Elliptic Curve over GF(2^n).">EC2N</a> ec(gf2n, <a class="code" href="class_polynomial_mod2.html" title="Polynomial with Coefficients in GF(2).">PolynomialMod2</a>(a,24), <a class="code" href="class_polynomial_mod2.html" title="Polynomial with Coefficients in GF(2).">PolynomialMod2</a>(b,24));
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         <a class="code" href="struct_e_c2_n_point.html" title="Elliptic Curve Point.">EC2N::Point</a> P;
<a name="l00684"></a>00684         ec.DecodePoint(P, (byte *)<span class="stringliteral">"\x04\x36\xB3\xDA\xF8\xA2\x32\x06\xF9\xC4\xF2\x99\xD7\xB2\x1A\x9C\x36\x91\x37\xF2\xC8\x4A\xE1\xAA\x0D"</span>
<a name="l00685"></a>00685                 <span class="stringliteral">"\x76\x5B\xE7\x34\x33\xB3\xF9\x5E\x33\x29\x32\xE7\x0E\xA2\x45\xCA\x24\x18\xEA\x0E\xF9\x80\x18\xFB"</span>, ec.EncodedPointSize());
<a name="l00686"></a>00686         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> n(<span class="stringliteral">"40000000000000000000000004a20e90c39067c893bbb9a5H"</span>);
<a name="l00687"></a>00687         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> d(<span class="stringliteral">"340562e1dda332f9d2aec168249b5696ee39d0ed4d03760fH"</span>);
<a name="l00688"></a>00688         <a class="code" href="struct_e_c2_n_point.html" title="Elliptic Curve Point.">EC2N::Point</a> Q(ec.Multiply(d, P));
<a name="l00689"></a>00689         <a class="code" href="struct_e_c_d_s_a.html" title="ECDSA">ECDSA&lt;EC2N, SHA&gt;::Signer</a> priv(ec, P, n, d);
<a name="l00690"></a>00690         <a class="code" href="struct_e_c_d_s_a.html" title="ECDSA">ECDSA&lt;EC2N, SHA&gt;::Verifier</a> pub(priv);
<a name="l00691"></a>00691 
<a name="l00692"></a>00692         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> h(<span class="stringliteral">"A9993E364706816ABA3E25717850C26C9CD0D89DH"</span>);
<a name="l00693"></a>00693         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> k(<span class="stringliteral">"3eeace72b4919d991738d521879f787cb590aff8189d2b69H"</span>);
<a name="l00694"></a>00694         byte sig[]=<span class="stringliteral">"\x03\x8e\x5a\x11\xfb\x55\xe4\xc6\x54\x71\xdc\xd4\x99\x84\x52\xb1\xe0\x2d\x8a\xf7\x09\x9b\xb9\x30"</span>
<a name="l00695"></a>00695                 <span class="stringliteral">"\x0c\x9a\x08\xc3\x44\x68\xc2\x44\xb4\xe5\xd6\xb2\x1b\x3c\x68\x36\x28\x07\x41\x60\x20\x32\x8b\x6e"</span>;
<a name="l00696"></a>00696         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> r(sig, 24);
<a name="l00697"></a>00697         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> s(sig+24, 24);
<a name="l00698"></a>00698 
<a name="l00699"></a>00699         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> rOut, sOut;
<a name="l00700"></a>00700         <span class="keywordtype">bool</span> fail, pass=<span class="keyword">true</span>;
<a name="l00701"></a>00701 
<a name="l00702"></a>00702         priv.RawSign(k, h, rOut, sOut);
<a name="l00703"></a>00703         fail = (rOut != r) || (sOut != s);
<a name="l00704"></a>00704         pass = pass &amp;&amp; !fail;
<a name="l00705"></a>00705 
<a name="l00706"></a>00706         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00707"></a>00707         cout &lt;&lt; <span class="stringliteral">"signature check against test vector\n"</span>;
<a name="l00708"></a>00708 
<a name="l00709"></a>00709         fail = !pub.VerifyMessage((byte *)<span class="stringliteral">"abc"</span>, 3, sig, <span class="keyword">sizeof</span>(sig));
<a name="l00710"></a>00710         pass = pass &amp;&amp; !fail;
<a name="l00711"></a>00711 
<a name="l00712"></a>00712         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00713"></a>00713         cout &lt;&lt; <span class="stringliteral">"verification check against test vector\n"</span>;
<a name="l00714"></a>00714 
<a name="l00715"></a>00715         fail = pub.VerifyMessage((byte *)<span class="stringliteral">"xyz"</span>, 3, sig, <span class="keyword">sizeof</span>(sig));
<a name="l00716"></a>00716         pass = pass &amp;&amp; !fail;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718         pass = SignatureValidate(priv, pub) &amp;&amp; pass;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720         <span class="keywordflow">return</span> pass;
<a name="l00721"></a>00721 }
<a name="l00722"></a>00722 
<a name="l00723"></a>00723 <span class="keywordtype">bool</span> ValidateESIGN()
<a name="l00724"></a>00724 {
<a name="l00725"></a>00725         cout &lt;&lt; <span class="stringliteral">"\nESIGN validation suite running...\n\n"</span>;
<a name="l00726"></a>00726 
<a name="l00727"></a>00727         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>, fail;
<a name="l00728"></a>00728 
<a name="l00729"></a>00729         <span class="keyword">const</span> <span class="keywordtype">char</span> *plain = <span class="stringliteral">"test"</span>;
<a name="l00730"></a>00730         <span class="keyword">const</span> byte *signature = (byte *)
<a name="l00731"></a>00731                 <span class="stringliteral">"\xA3\xE3\x20\x65\xDE\xDA\xE7\xEC\x05\xC1\xBF\xCD\x25\x79\x7D\x99\xCD\xD5\x73\x9D\x9D\xF3\xA4\xAA\x9A\xA4\x5A\xC8\x23\x3D\x0D\x37\xFE\xBC\x76\x3F\xF1\x84\xF6\x59"</span>
<a name="l00732"></a>00732                 <span class="stringliteral">"\x14\x91\x4F\x0C\x34\x1B\xAE\x9A\x5C\x2E\x2E\x38\x08\x78\x77\xCB\xDC\x3C\x7E\xA0\x34\x44\x5B\x0F\x67\xD9\x35\x2A\x79\x47\x1A\x52\x37\x71\xDB\x12\x67\xC1\xB6\xC6"</span>
<a name="l00733"></a>00733                 <span class="stringliteral">"\x66\x73\xB3\x40\x2E\xD6\xF2\x1A\x84\x0A\xB6\x7B\x0F\xEB\x8B\x88\xAB\x33\xDD\xE4\x83\x21\x90\x63\x2D\x51\x2A\xB1\x6F\xAB\xA7\x5C\xFD\x77\x99\xF2\xE1\xEF\x67\x1A"</span>
<a name="l00734"></a>00734                 <span class="stringliteral">"\x74\x02\x37\x0E\xED\x0A\x06\xAD\xF4\x15\x65\xB8\xE1\xD1\x45\xAE\x39\x19\xB4\xFF\x5D\xF1\x45\x7B\xE0\xFE\x72\xED\x11\x92\x8F\x61\x41\x4F\x02\x00\xF2\x76\x6F\x7C"</span>
<a name="l00735"></a>00735                 <span class="stringliteral">"\x79\xA2\xE5\x52\x20\x5D\x97\x5E\xFE\x39\xAE\x21\x10\xFB\x35\xF4\x80\x81\x41\x13\xDD\xE8\x5F\xCA\x1E\x4F\xF8\x9B\xB2\x68\xFB\x28"</span>;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> keys(<span class="stringliteral">"esig1536.dat"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00738"></a>00738         <a class="code" href="struct_e_s_i_g_n.html" title="ESIGN, as defined in IEEE P1363a.">ESIGN&lt;SHA&gt;::Signer</a> signer(keys);
<a name="l00739"></a>00739         <a class="code" href="struct_e_s_i_g_n.html" title="ESIGN, as defined in IEEE P1363a.">ESIGN&lt;SHA&gt;::Verifier</a> verifier(signer);
<a name="l00740"></a>00740 
<a name="l00741"></a>00741         fail = !SignatureValidate(signer, verifier);
<a name="l00742"></a>00742         pass = pass &amp;&amp; !fail;
<a name="l00743"></a>00743 
<a name="l00744"></a>00744         fail = !verifier.VerifyMessage((byte *)plain, strlen(plain), signature, verifier.SignatureLength());
<a name="l00745"></a>00745         pass = pass &amp;&amp; !fail;
<a name="l00746"></a>00746 
<a name="l00747"></a>00747         cout &lt;&lt; (fail ? <span class="stringliteral">"FAILED    "</span> : <span class="stringliteral">"passed    "</span>);
<a name="l00748"></a>00748         cout &lt;&lt; <span class="stringliteral">"verification check against test vector\n"</span>;
<a name="l00749"></a>00749 
<a name="l00750"></a>00750         cout &lt;&lt; <span class="stringliteral">"Generating signature key from seed..."</span> &lt;&lt; endl;
<a name="l00751"></a>00751         <a class="code" href="class_invertible_e_s_i_g_n_function.html" title="_">InvertibleESIGNFunction</a> priv;
<a name="l00752"></a>00752         priv.<a class="code" href="class_invertible_e_s_i_g_n_function.html#241b733193f9f420f188ca6f57d49c27">GenerateRandom</a>(GlobalRNG(), MakeParameters(<span class="stringliteral">"Seed"</span>, <a class="code" href="class_const_byte_array_parameter.html" title="used to pass byte array input as part of a NameValuePairs object">ConstByteArrayParameter</a>((<span class="keyword">const</span> byte *)<span class="stringliteral">"test"</span>, 4))(<span class="stringliteral">"KeySize"</span>, 3*512));
<a name="l00753"></a>00753 
<a name="l00754"></a>00754         fail = !SignatureValidate(signer, verifier);
<a name="l00755"></a>00755         pass = pass &amp;&amp; !fail;
<a name="l00756"></a>00756 
<a name="l00757"></a>00757         <span class="keywordflow">return</span> pass;
<a name="l00758"></a>00758 }
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 11:11:25 2007 for Crypto++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
