<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Crypto++: rc2.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>rc2.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// rc2.cpp - written and placed in the public domain by Wei Dai</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include "pch.h"</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include "<a class="code" href="rc2_8h.html">rc2.h</a>"</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include "misc.h"</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include "argnames.h"</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 NAMESPACE_BEGIN(CryptoPP)
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 void <a class="code" href="class_r_c2.html" title="RC2">RC2</a>::Base::UncheckedSetKey(const byte *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keyLen, const <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;params)
<a name="l00011"></a>00011 {
<a name="l00012"></a>00012         AssertValidKeyLength(keyLen);
<a name="l00013"></a>00013 
<a name="l00014"></a>00014         <span class="keywordtype">int</span> effectiveLen = params.GetIntValueWithDefault(<a class="code" href="namespace_name.html#8e61b2d95662464a57395892801c47dd" title="int, in bits">Name::EffectiveKeyLength</a>(), DEFAULT_EFFECTIVE_KEYLENGTH);
<a name="l00015"></a>00015         <span class="keywordflow">if</span> (effectiveLen &gt; MAX_EFFECTIVE_KEYLENGTH)
<a name="l00016"></a>00016                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(<span class="stringliteral">"RC2: effective key length parameter exceeds maximum"</span>);
<a name="l00017"></a>00017 
<a name="l00018"></a>00018         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> PITABLE[256] = {
<a name="l00019"></a>00019                 217,120,249,196, 25,221,181,237, 40,233,253,121, 74,160,216,157,
<a name="l00020"></a>00020                 198,126, 55,131, 43,118, 83,142, 98, 76,100,136, 68,139,251,162,
<a name="l00021"></a>00021                  23,154, 89,245,135,179, 79, 19, 97, 69,109,141,  9,129,125, 50,
<a name="l00022"></a>00022                 189,143, 64,235,134,183,123, 11,240,149, 33, 34, 92,107, 78,130,
<a name="l00023"></a>00023                  84,214,101,147,206, 96,178, 28,115, 86,192, 20,167,140,241,220,
<a name="l00024"></a>00024                  18,117,202, 31, 59,190,228,209, 66, 61,212, 48,163, 60,182, 38,
<a name="l00025"></a>00025                 111,191, 14,218, 70,105,  7, 87, 39,242, 29,155,188,148, 67,  3,
<a name="l00026"></a>00026                 248, 17,199,246,144,239, 62,231,  6,195,213, 47,200,102, 30,215,
<a name="l00027"></a>00027                   8,232,234,222,128, 82,238,247,132,170,114,172, 53, 77,106, 42,
<a name="l00028"></a>00028                 150, 26,210,113, 90, 21, 73,116, 75,159,208, 94,  4, 24,164,236,
<a name="l00029"></a>00029                 194,224, 65,110, 15, 81,203,204, 36,145,175, 80,161,244,112, 57,
<a name="l00030"></a>00030                 153,124, 58,133, 35,184,180,122,252,  2, 54, 91, 37, 85,151, 49,
<a name="l00031"></a>00031                  45, 93,250,152,227,138,146,174,  5,223, 41, 16,103,108,186,201,
<a name="l00032"></a>00032                 211,  0,230,207,225,158,168, 44, 99, 22,  1, 63, 88,226,137,169,
<a name="l00033"></a>00033                  13, 56, 52, 27,171, 51,255,176,187, 72, 12, 95,185,177,205, 46,
<a name="l00034"></a>00034                 197,243,219, 71,229,165,156,119, 10,166, 32,104,254,127,193,173};
<a name="l00035"></a>00035 
<a name="l00036"></a>00036         <a class="code" href="class_sec_block.html" title="a block of memory allocated using A">SecByteBlock</a> L(128);
<a name="l00037"></a>00037         memcpy(L, key, keyLen);
<a name="l00038"></a>00038 
<a name="l00039"></a>00039         <span class="keywordtype">int</span> i;
<a name="l00040"></a>00040         <span class="keywordflow">for</span> (i=keyLen; i&lt;128; i++)
<a name="l00041"></a>00041                 L[i] = PITABLE[(L[i-1] + L[i-keyLen]) &amp; 255];
<a name="l00042"></a>00042 
<a name="l00043"></a>00043         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> T8 = (effectiveLen+7) / 8;
<a name="l00044"></a>00044         byte TM = 255 &gt;&gt; ((8-(effectiveLen%8))%8);
<a name="l00045"></a>00045         L[128-T8] = PITABLE[L[128-T8] &amp; TM];
<a name="l00046"></a>00046 
<a name="l00047"></a>00047         <span class="keywordflow">for</span> (i=127-T8; i&gt;=0; i--)
<a name="l00048"></a>00048                 L[i] = PITABLE[L[i+1] ^ L[i+T8]];
<a name="l00049"></a>00049 
<a name="l00050"></a>00050         <span class="keywordflow">for</span> (i=0; i&lt;64; i++)
<a name="l00051"></a>00051                 K[i] = L[2*i] + (L[2*i+1] &lt;&lt; 8);
<a name="l00052"></a>00052 }
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keyword">typedef</span> <a class="code" href="struct_block_get_and_put.html">BlockGetAndPut&lt;word16, LittleEndian&gt;</a> <a class="code" href="struct_block_get_and_put.html">Block</a>;
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="keywordtype">void</span> RC2::Enc::ProcessAndXorBlock(<span class="keyword">const</span> byte *inBlock, <span class="keyword">const</span> byte *xorBlock, byte *outBlock)<span class="keyword"> const</span>
<a name="l00057"></a>00057 <span class="keyword"></span>{
<a name="l00058"></a>00058         word16 R0, R1, R2, R3;
<a name="l00059"></a>00059         <a class="code" href="struct_block_get_and_put.html#07781cc0817613fe47e8070999cf4b95">Block::Get</a>(inBlock)(R0)(R1)(R2)(R3);
<a name="l00060"></a>00060 
<a name="l00061"></a>00061         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)
<a name="l00062"></a>00062         {
<a name="l00063"></a>00063                 R0 += (R1 &amp; ~R3) + (R2 &amp; R3) + K[4*i+0];
<a name="l00064"></a>00064                 R0 = rotlFixed(R0, 1);
<a name="l00065"></a>00065 
<a name="l00066"></a>00066                 R1 += (R2 &amp; ~R0) + (R3 &amp; R0) + K[4*i+1];
<a name="l00067"></a>00067                 R1 = rotlFixed(R1, 2);
<a name="l00068"></a>00068 
<a name="l00069"></a>00069                 R2 += (R3 &amp; ~R1) + (R0 &amp; R1) + K[4*i+2];
<a name="l00070"></a>00070                 R2 = rotlFixed(R2, 3);
<a name="l00071"></a>00071 
<a name="l00072"></a>00072                 R3 += (R0 &amp; ~R2) + (R1 &amp; R2) + K[4*i+3];
<a name="l00073"></a>00073                 R3 = rotlFixed(R3, 5);
<a name="l00074"></a>00074 
<a name="l00075"></a>00075                 <span class="keywordflow">if</span> (i == 4 || i == 10)
<a name="l00076"></a>00076                 {
<a name="l00077"></a>00077                         R0 += K[R3 &amp; 63];
<a name="l00078"></a>00078                         R1 += K[R0 &amp; 63];
<a name="l00079"></a>00079                         R2 += K[R1 &amp; 63];
<a name="l00080"></a>00080                         R3 += K[R2 &amp; 63];
<a name="l00081"></a>00081                 }
<a name="l00082"></a>00082         }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084         <a class="code" href="struct_block_get_and_put.html#63d96a17e8118407e02896d0b0f8d92d">Block::Put</a>(xorBlock, outBlock)(R0)(R1)(R2)(R3);
<a name="l00085"></a>00085 }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="keywordtype">void</span> RC2::Dec::ProcessAndXorBlock(<span class="keyword">const</span> byte *inBlock, <span class="keyword">const</span> byte *xorBlock, byte *outBlock)<span class="keyword"> const</span>
<a name="l00088"></a>00088 <span class="keyword"></span>{
<a name="l00089"></a>00089         word16 R0, R1, R2, R3;
<a name="l00090"></a>00090         <a class="code" href="struct_block_get_and_put.html#07781cc0817613fe47e8070999cf4b95">Block::Get</a>(inBlock)(R0)(R1)(R2)(R3);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 15; i &gt;= 0; i--)
<a name="l00093"></a>00093         {
<a name="l00094"></a>00094                 <span class="keywordflow">if</span> (i == 4 || i == 10)
<a name="l00095"></a>00095                 {
<a name="l00096"></a>00096                         R3 -= K[R2 &amp; 63];
<a name="l00097"></a>00097                         R2 -= K[R1 &amp; 63];
<a name="l00098"></a>00098                         R1 -= K[R0 &amp; 63];
<a name="l00099"></a>00099                         R0 -= K[R3 &amp; 63];
<a name="l00100"></a>00100                 }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102                 R3 = rotrFixed(R3, 5);
<a name="l00103"></a>00103                 R3 -= (R0 &amp; ~R2) + (R1 &amp; R2) + K[4*i+3];
<a name="l00104"></a>00104 
<a name="l00105"></a>00105                 R2 = rotrFixed(R2, 3);
<a name="l00106"></a>00106                 R2 -= (R3 &amp; ~R1) + (R0 &amp; R1) + K[4*i+2];
<a name="l00107"></a>00107 
<a name="l00108"></a>00108                 R1 = rotrFixed(R1, 2);
<a name="l00109"></a>00109                 R1 -= (R2 &amp; ~R0) + (R3 &amp; R0) + K[4*i+1];
<a name="l00110"></a>00110 
<a name="l00111"></a>00111                 R0 = rotrFixed(R0, 1);
<a name="l00112"></a>00112                 R0 -= (R1 &amp; ~R3) + (R2 &amp; R3) + K[4*i+0];
<a name="l00113"></a>00113         }
<a name="l00114"></a>00114 
<a name="l00115"></a>00115         <a class="code" href="struct_block_get_and_put.html#63d96a17e8118407e02896d0b0f8d92d">Block::Put</a>(xorBlock, outBlock)(R0)(R1)(R2)(R3);
<a name="l00116"></a>00116 }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 NAMESPACE_END
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 11:11:23 2007 for Crypto++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
